// Generated by dts-bundle-generator v8.0.1

/**
 * 构造函数
 */
export interface Type<T = any> extends Function {
	new (...args: any[]): T;
}
export interface SceneInitArgs {
	id: number;
	instanceId?: number;
	sceneType: string;
	name: string;
	parent?: Entity;
}
export declare class Scene extends Entity {
	name: string;
	sceneType: string;
	set domain(value: Entity);
	get domain(): Entity;
	set parent(value: Entity);
	init(args: SceneInitArgs): void;
}
export declare abstract class Entity {
	get parent(): Entity;
	set parent(value: Entity);
	get domain(): Entity;
	set domain(value: Entity);
	instanceId: number;
	id: number;
	get isDisposed(): boolean;
	get children(): Map<number, Entity>;
	get components(): Map<Type<Entity>, Entity>;
	protected _domain: Entity;
	private _children;
	private _components;
	protected _parent: Entity;
	private status;
	private get isFromPool();
	private set isFromPool(value);
	private get isComponent();
	private set isComponent(value);
	protected get isCreated(): boolean;
	protected set isCreated(value: boolean);
	protected get isNew(): boolean;
	protected set isNew(value: boolean);
	protected get isRegister(): boolean;
	protected set isRegister(value: boolean);
	private set componentParent(value);
	addComponent(component: Entity): Entity;
	addComponent<T extends Entity>(type: Type<T>): T;
	addComponent<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	tryAddComponent<T extends Entity>(type: Type<T>): T;
	private addComponentByEntity;
	private addComponentByCtor;
	addChild(entity: Entity): Entity;
	addChild<T extends Entity>(type: Type<T>): T;
	addChild<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	addChildWithId<T extends Entity>(type: Type<T>, id: number, isFromPool?: boolean): T;
	private addChildByEntity;
	private addChildByType;
	private create;
	private removeFromChildren;
	private removeFromComponents;
	private addToComponents;
	private addToChildren;
	getComponent<K extends Entity>(type: new () => K): K;
	removeComponent<T extends Entity>(type: Type<T>): T;
	getParent<T extends Entity>(type: Type<T>): T;
	getChild<T extends Entity>(type: Type<T>, id: number): T;
	removeChild(id: number): void;
	dispose(): void;
	domainScene(): Scene;
	getType(): Type;
	awake?(): void;
	update?(): void;
	lateUpdate?(): void;
	destroy?(): void;
}
declare abstract class Singleton {
	private static _inst;
	private _isDisposed;
	static getInst<T extends Singleton>(this: new () => T): T;
	get isDisposed(): boolean;
	destroy?(): void;
	dispose(): void;
	_onPreDestroy(): void;
}
export interface ILifeCycle {
	get isDisposed(): boolean;
	instanceId?: number;
	awake?(): void;
	update?(): void;
	lateUpdate?(): void;
	destroy?(): void;
}
/**
 * 管理实体组件的生命周期
 */
export declare class EntityLifiCycleMgr extends Singleton {
	private readonly queues;
	awake(): void;
	registerSystem(component: ILifeCycle): void;
	awakeComEvent(component: ILifeCycle): void;
	destroyComEvent(component: ILifeCycle): void;
	update(): void;
	lateUpdate(): void;
}
/**
 * 保存根节点
 */
export declare class Root extends Singleton {
	get scene(): Scene;
	private _scene;
	awake(): void;
}
export declare enum SceneType {
	None = "None",
	Process = "Process",
	Client = "Client",
	Current = "Current"
}
export declare class ObjectPool extends Singleton {
	private _pool;
	fetch<T>(type: Type<T>): T;
	recycle(obj: object): void;
}
export interface ILog {
	log(str: string): void;
	warn(str: string): void;
	error(str: string): void;
}
/**
 * Logger
 */
export declare class Logger extends Singleton {
	private _iLog;
	set iLog(value: ILog);
	private static readonly LOG_LEVEL;
	private static readonly WARN_LEVEL;
	log(str: string, ...args: any[]): void;
	warn(str: string, ...args: any[]): void;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	error(str: string, ...args: any[]): void;
	private checkLogLevel;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreLog;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreWarn;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	private coreError;
}
export declare function log(str: string, ...args: any[]): void;
export declare function warn(str: string, ...args: any[]): void;
export declare function error(str: string, ...args: any[]): void;

export {};
