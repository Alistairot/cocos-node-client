import{Component}from"cc";class Singleton{constructor(){this._isDisposed=!1}static getInst(){let t=this;if(null==t._inst)throw new Error(`Singleton is not initialized or destroyed, name is ${t.name}`);return t._inst}get isDisposed(){return this._isDisposed}dispose(){this._onPreDestroy()}_onPreDestroy(){this._isDisposed||(this.destroy&&this.destroy(),Singleton._inst=null,this._isDisposed=!0)}}class ObjectPool extends Singleton{constructor(){super(...arguments),this._pool=new Map}fetch(t){let e=this._pool.get(t);return e?0===e.length?new t:e.shift():new t}recycle(t){let e=t.constructor,s=this._pool.get(e);s||(s=[],this._pool.set(e,s)),s.length>1e3?console.warn(`pool ${e.name} is too large`):s.push(t)}}class JsHelper{static getMethodName(){let t=(new Error).stack.split("at ")[2],e=t.indexOf(" ");return t.substring(0,e)}static getRootDirName(t){return t.split("/")[0]}static sleep(t){return new Promise((e=>setTimeout(e,t)))}static isNullOrEmpty(t){return null==t||(0==t.length||void 0)}static getStringHashCode(t){let e=5381,s=t.length;for(;s;)e=33*e^t.charCodeAt(--s);return e>>>0}static modeString(t,e){return this.getStringHashCode(t)%e}static formatStr(t,...e){let s;if("string"!=typeof t){let t=new Error("formatStr args[0] is not string");return t.name+t.stack}return 0==e.length?t:(s=t.replace(/\{\{|\}\}|\{(\d+)\}/g,(function(t,s){return"{{"==t?"{":"}}"==t?"}":e[s]})),s)}}class Options extends Singleton{constructor(){super(...arguments),this.isServer=!1,this.process=1,this.zone=1,this.logLevel=1,this.develop=!0,this.console=!1,this._argsMap=new Map}_setArgs(t,e){this._argsMap.set(t,e)}getArgs(t){if(!this._argsMap.has(t))throw new Error(`Options.getArgs ${t} not exist`);return this._argsMap.get(t)}}class Logger extends Singleton{set iLog(t){this._iLog=t}log(t,...e){if(this.checkLogLevel(Logger.LOG_LEVEL)){let s=JsHelper.formatStr(t,...e);this._iLog.log(s)}}warn(t,...e){if(this.checkLogLevel(Logger.WARN_LEVEL)){let s=JsHelper.formatStr(t,...e);this._iLog.warn(s)}}error(t,...e){let s=JsHelper.formatStr(t,...e),i=new Error,r=JsHelper.formatStr("{0}, stack: {1}",s,i.stack);this._iLog.error(r)}checkLogLevel(t){return Options.getInst().logLevel<=t}coreLog(t,...e){let s=JsHelper.formatStr(t,...e);this._iLog.log(s)}coreWarn(t,...e){let s=JsHelper.formatStr(t,...e);this._iLog.warn(s)}coreError(t,...e){let s=JsHelper.formatStr(t,...e),i=new Error,r=JsHelper.formatStr("{0}, stack: {1}",s,i.stack);this._iLog.error(r)}}function log(t,...e){Logger.getInst().log(t,...e)}function warn(t,...e){Logger.getInst().warn(t,...e)}function error(t,...e){Logger.getInst().error(t,...e)}Logger.LOG_LEVEL=1,Logger.WARN_LEVEL=2;class SizeFollow extends Component{}class TimeInfo extends Singleton{awake(){this.serverMinusClientTime=0}clientNow(){return Date.now()}serverNow(){return this.clientNow()+this.serverMinusClientTime}}function coreWarn(t,...e){let s=`[core]: ${JsHelper.formatStr(t,...e)}`;try{Logger.getInst().coreWarn(s)}catch(t){console.warn(s)}}function coreError(t,...e){let s=`[core]: ${JsHelper.formatStr(t,...e)}`;try{Logger.getInst().coreError(s)}catch(t){console.error(s)}}const timeBit$1=30n,processBit=14n,valueBit$1=20n,powTimeBit$1=2n**timeBit$1-1n,powProcessBit=2n**processBit-1n,powValueBit$1=2n**valueBit$1-1n,epoch$1=new Date(2023,4,1).getTime();class IdStruct{static get inst(){return null==IdStruct._inst&&(IdStruct._inst=new IdStruct),IdStruct._inst}static generate(){0==this.lastTime&&(this.lastTime=this.timeSinceEpoch(),this.lastTime<=0&&(coreWarn(`${(new this).constructor.name}: lastTime less than 0: ${this.lastTime}`),this.lastTime=1));let t=this.timeSinceEpoch();t>this.lastTime?(this.lastTime=t,this.idCount=0):(++this.idCount,this.idCount>powValueBit$1&&(++this.lastTime,this.idCount=0,coreError(`${(new this).constructor.name}: idCount per sec overflow: ${t} ${this.lastTime}`)));let e=IdStruct.inst;return e.init(this.lastTime,Options.getInst().process,this.idCount),e.result}static convertToId(t,e,s){return IdStruct.inst.init(t,e,s).result}static parseId(t){return IdStruct.inst.initById(t)}static timeSinceEpoch(){let t=(TimeInfo.getInst().clientNow()-epoch$1)/1e3;return Math.floor(t)}initById(t){return this.result=t,this.time=t&powTimeBit$1,t>>=timeBit$1,this.process=t&powProcessBit,t>>=processBit,this.value=t&powValueBit$1,this}init(t,e,s){return this.time=BigInt(t),this.process=BigInt(e),this.value=BigInt(s),this.updateResult(),this}updateResult(){this.result=this.value,this.result<<=processBit,this.result|=this.process,this.result<<=timeBit$1,this.result|=this.time}}IdStruct.lastTime=0,IdStruct.idCount=0;const timeBit=32n,valueBit=32n,powTimeBit=2n**timeBit-1n,powValueBit=2n**valueBit-1n,epoch=new Date(2023,4,1).getTime();class InstanceIdStruct{static get inst(){return null==InstanceIdStruct._inst&&(InstanceIdStruct._inst=new InstanceIdStruct),InstanceIdStruct._inst}static generate(){0==this.lastTime&&(this.lastTime=this.timeSinceEpoch(),this.lastTime<=0&&(coreWarn(`${(new this).constructor.name}: lastTime less than 0: ${this.lastTime}`),this.lastTime=1));let t=this.timeSinceEpoch();t>this.lastTime?(this.lastTime=t,this.idCount=0):(++this.idCount,this.idCount>powValueBit&&(++this.lastTime,this.idCount=0,coreError(`${(new this).constructor.name}: idCount per sec overflow: ${t} ${this.lastTime}`)));let e=InstanceIdStruct.inst;return e.init(this.lastTime,this.idCount),e.result}static convertToId(t,e){return InstanceIdStruct.inst.init(t,e).result}static parseId(t){return InstanceIdStruct.inst.initById(t)}static timeSinceEpoch(){let t=(TimeInfo.getInst().clientNow()-epoch)/1e3;return Math.floor(t)}initById(t){return this.result=t,this.time=t&powTimeBit,t>>=timeBit,this.value=t&powValueBit,this}init(t,e){return this.time=BigInt(t),this.value=BigInt(e),this.updateResult(),this}updateResult(){this.result=this.value,this.result<<=timeBit,this.result|=this.time}}InstanceIdStruct.lastTime=0,InstanceIdStruct.idCount=0;class IdGenerator extends Singleton{generateInstanceId(){return InstanceIdStruct.generate()}generateId(){return IdStruct.generate()}}export{IdGenerator,Logger,ObjectPool,SizeFollow,error,log,warn};