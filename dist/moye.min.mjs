import{Component}from"cc";class Singleton{constructor(){this._isDisposed=!1}static getInst(){let t=this,e=t._inst;if(null==e)throw new Error(`Singleton is not initialized, name is ${t.name}`);return e}get isDisposed(){return this._isDisposed}dispose(){this._onPreDestroy()}_onPreDestroy(){this._isDisposed||(this.destroy&&this.destroy(),Singleton._inst=null,this._isDisposed=!0)}}class ObjectPool extends Singleton{constructor(){super(...arguments),this._pool=new Map}fetch(t){let e=this._pool.get(t);return e?0===e.length?new t:e.shift():new t}recycle(t){let e=t.constructor,r=this._pool.get(e);r||(r=[],this._pool.set(e,r)),r.length>1e3?console.warn(`pool ${e.name} is too large`):r.push(t)}}class JsHelper{static getMethodName(){let t=(new Error).stack.split("at ")[2],e=t.indexOf(" ");return t.substring(0,e)}static getRootDirName(t){return t.split("/")[0]}static sleep(t){return new Promise((e=>setTimeout(e,t)))}static isNullOrEmpty(t){return null==t||(0==t.length||void 0)}static getStringHashCode(t){let e=5381,r=t.length;for(;r;)e=33*e^t.charCodeAt(--r);return e>>>0}static modeString(t,e){return this.getStringHashCode(t)%e}static formatStr(t,...e){let r;if("string"!=typeof t){let t=new Error("formatStr args[0] is not string");return t.name+t.stack}return 0==e.length?t:(r=t.replace(/\{\{|\}\}|\{(\d+)\}/g,(function(t,r){return"{{"==t?"{":"}}"==t?"}":e[r]})),r)}}class Options extends Singleton{constructor(){super(...arguments),this.isServer=!1,this.process=1,this.zone=1,this.logLevel=1,this.develop=!0,this.console=!1,this._argsMap=new Map}_setArgs(t,e){this._argsMap.set(t,e)}getArgs(t){if(!this._argsMap.has(t))throw new Error(`Options.getArgs ${t} not exist`);return this._argsMap.get(t)}}class Logger extends Singleton{set iLog(t){this._iLog=t}log(t,...e){if(this.checkLogLevel(Logger.LOG_LEVEL)){let r=JsHelper.formatStr(t,...e);this._iLog.log(r)}}warn(t,...e){if(this.checkLogLevel(Logger.WARN_LEVEL)){let r=JsHelper.formatStr(t,...e);this._iLog.warn(r)}}error(t,...e){let r=JsHelper.formatStr(t,...e),s=new Error,o=JsHelper.formatStr("{0}, stack: {1}",r,s.stack);this._iLog.error(o)}checkLogLevel(t){return Options.getInst().logLevel<=t}coreLog(t,...e){let r=JsHelper.formatStr(t,...e);this._iLog.log(r)}coreWarn(t,...e){let r=JsHelper.formatStr(t,...e);this._iLog.warn(r)}coreError(t,...e){let r=JsHelper.formatStr(t,...e),s=new Error,o=JsHelper.formatStr("{0}, stack: {1}",r,s.stack);this._iLog.error(o)}}function log(t,...e){Logger.getInst().log(t,...e)}function warn(t,...e){Logger.getInst().warn(t,...e)}function error(t,...e){Logger.getInst().error(t,...e)}Logger.LOG_LEVEL=1,Logger.WARN_LEVEL=2;class SizeFollow extends Component{}export{Logger,ObjectPool,SizeFollow,error,log,warn};