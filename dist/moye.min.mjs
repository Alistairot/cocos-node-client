import{_decorator,Component,director}from"cc";class Singleton{constructor(){this._isDisposed=!1}static getInst(){const t=this;if(null==t._inst)throw new Error(`Singleton is not initialized or destroyed, name is ${t.name}`);return t._inst}get isDisposed(){return this._isDisposed}dispose(){this._onPreDestroy()}_onPreDestroy(){this._isDisposed||(this.destroy&&this.destroy(),Singleton._inst=null,this._isDisposed=!0)}}class TimeInfo extends Singleton{awake(){this.serverMinusClientTime=0}clientNow(){return Date.now()}serverNow(){return this.clientNow()+this.serverMinusClientTime}}class JsHelper{static getMethodName(){const t=(new Error).stack.split("at ")[2],e=t.indexOf(" ");return t.substring(0,e)}static getRootDirName(t){return t.split("/")[0]}static sleep(t){return new Promise((e=>setTimeout(e,t)))}static isNullOrEmpty(t){return null==t||(0==t.length||void 0)}static getStringHashCode(t){let e=5381,s=t.length;for(;s;)e=33*e^t.charCodeAt(--s);return e>>>0}static modeString(t,e){return this.getStringHashCode(t)%e}static formatStr(t,...e){if("string"!=typeof t){const t=new Error("formatStr args[0] is not string");return t.name+t.stack}if(0==e.length)return t;return t.replace(/\{\{|\}\}|\{(\d+)\}/g,(function(t,s){return"{{"==t?"{":"}}"==t?"}":e[s]}))}}class Options extends Singleton{constructor(){super(...arguments),this.isServer=!1,this.logLevel=1,this.develop=!0}}class LoggerDefault{log(t){console.log(t)}warn(t){console.warn(t)}error(t){console.error(t)}}class Logger extends Singleton{set iLog(t){this._logInst=t}get _iLog(){return this._logInst||(this._logInst=new LoggerDefault,this._logInst.warn("not set iLog, use default logger")),this._logInst}log(t,...e){if(this.checkLogLevel(Logger.LOG_LEVEL)){const s=JsHelper.formatStr(t,...e);this._iLog.log(s)}}warn(t,...e){if(this.checkLogLevel(Logger.WARN_LEVEL)){const s=JsHelper.formatStr(t,...e);this._iLog.warn(s)}}error(t,...e){const s=JsHelper.formatStr(t,...e),n=new Error,i=JsHelper.formatStr("{0}, stack: {1}",s,n.stack);this._iLog.error(i)}checkLogLevel(t){return Options.getInst().logLevel<=t}coreLog(t,...e){const s=JsHelper.formatStr(t,...e);this._iLog.log(s)}coreWarn(t,...e){const s=JsHelper.formatStr(t,...e);this._iLog.warn(s)}coreError(t,...e){const s=JsHelper.formatStr(t,...e),n=new Error,i=JsHelper.formatStr("{0}, stack: {1}",s,n.stack);this._iLog.error(i)}}function log(t,...e){Logger.getInst().log(t,...e)}function warn(t,...e){Logger.getInst().warn(t,...e)}function error(t,...e){Logger.getInst().error(t,...e)}function coreLog(t,...e){const s=`[core]: ${JsHelper.formatStr(t,...e)}`;try{Logger.getInst().coreLog(s)}catch(t){console.log(s)}}function coreWarn(t,...e){const s=`[core]: ${JsHelper.formatStr(t,...e)}`;try{Logger.getInst().coreWarn(s)}catch(t){console.warn(s)}}function coreError(t,...e){const s=`[core]: ${JsHelper.formatStr(t,...e)}`;try{Logger.getInst().coreError(s)}catch(t){console.error(s)}}Logger.LOG_LEVEL=1,Logger.WARN_LEVEL=2;const timeBit$1=30n,processBit=14n,valueBit$1=20n,powTimeBit$1=2n**timeBit$1-1n,powProcessBit=2n**processBit-1n,powValueBit$1=2n**valueBit$1-1n,epoch$1=new Date(2023,4,1).getTime();class IdStruct{static get inst(){return null==IdStruct._inst&&(IdStruct._inst=new IdStruct),IdStruct._inst}static generate(){0==this._lastTime&&(this._lastTime=this.timeSinceEpoch(),this._lastTime<=0&&(coreWarn(`${(new this).constructor.name}: lastTime less than 0: ${this._lastTime}`),this._lastTime=1));const t=this.timeSinceEpoch();t>this._lastTime?(this._lastTime=t,this._idCount=0):(++this._idCount,this._idCount>powValueBit$1&&(++this._lastTime,this._idCount=0,coreError(`${(new this).constructor.name}: idCount per sec overflow: ${t} ${this._lastTime}`)));const e=IdStruct.inst;return e.init(this._lastTime,1,this._idCount),e.result}static convertToId(t,e,s){return IdStruct.inst.init(t,e,s).result}static parseId(t){return IdStruct.inst.initById(t)}static timeSinceEpoch(){const t=(TimeInfo.getInst().clientNow()-epoch$1)/1e3;return Math.floor(t)}initById(t){return this.result=t,this.time=t&powTimeBit$1,t>>=timeBit$1,this.process=t&powProcessBit,t>>=processBit,this.value=t&powValueBit$1,this}init(t,e,s){return this.time=BigInt(t),this.process=BigInt(e),this.value=BigInt(s),this.updateResult(),this}updateResult(){this.result=this.value,this.result<<=processBit,this.result|=this.process,this.result<<=timeBit$1,this.result|=this.time}}IdStruct._lastTime=0,IdStruct._idCount=0;const timeBit=32n,valueBit=32n,powTimeBit=2n**timeBit-1n,powValueBit=2n**valueBit-1n,epoch=new Date(2023,4,1).getTime();class InstanceIdStruct{static get inst(){return null==InstanceIdStruct._inst&&(InstanceIdStruct._inst=new InstanceIdStruct),InstanceIdStruct._inst}static generate(){0==this._lastTime&&(this._lastTime=this.timeSinceEpoch(),this._lastTime<=0&&(coreWarn(`${(new this).constructor.name}: lastTime less than 0: ${this._lastTime}`),this._lastTime=1));const t=this.timeSinceEpoch();t>this._lastTime?(this._lastTime=t,this._idCount=0):(++this._idCount,this._idCount>powValueBit&&(++this._lastTime,this._idCount=0,coreError(`${(new this).constructor.name}: idCount per sec overflow: ${t} ${this._lastTime}`)));const e=InstanceIdStruct.inst;return e.init(this._lastTime,this._idCount),e.result}static convertToId(t,e){return InstanceIdStruct.inst.init(t,e).result}static parseId(t){return InstanceIdStruct.inst.initById(t)}static timeSinceEpoch(){const t=(TimeInfo.getInst().clientNow()-epoch)/1e3;return Math.floor(t)}initById(t){return this.result=t,this.time=t&powTimeBit,t>>=timeBit,this.value=t&powValueBit,this}init(t,e){return this.time=BigInt(t),this.value=BigInt(e),this.updateResult(),this}updateResult(){this.result=this.value,this.result<<=timeBit,this.result|=this.time}}InstanceIdStruct._lastTime=0,InstanceIdStruct._idCount=0;class IdGenerator extends Singleton{generateInstanceId(){return InstanceIdStruct.generate()}generateId(){return IdStruct.generate()}}class ObjectPool extends Singleton{constructor(){super(...arguments),this._pool=new Map}fetch(t){const e=this._pool.get(t);return e?0===e.length?new t:e.shift():new t}recycle(t){const e=t.constructor;let s=this._pool.get(e);s||(s=[],this._pool.set(e,s)),s.length>1e3?console.warn(`pool ${e.name} is too large`):s.push(t)}}class EntityCenter extends Singleton{constructor(){super(...arguments),this._allEntities=new Map}add(t){this._allEntities.set(t.instanceId,t)}remove(t){this._allEntities.delete(t)}get(t){return this._allEntities.get(t)}}var InstanceQueueIndex,EntityStatus,SceneType;!function(t){t[t.NONE=-1]="NONE",t[t.UPDATE=0]="UPDATE",t[t.LATE_UPDATE=1]="LATE_UPDATE",t[t.MAX=2]="MAX"}(InstanceQueueIndex||(InstanceQueueIndex={}));class EntityLifiCycleMgr extends Singleton{constructor(){super(...arguments),this._queues=new Array(InstanceQueueIndex.MAX)}awake(){for(let t=0;t<this._queues.length;t++)this._queues[t]=[]}registerSystem(t){t.update&&this._queues[InstanceQueueIndex.UPDATE].push(t.instanceId),t.lateUpdate&&this._queues[InstanceQueueIndex.LATE_UPDATE].push(t.instanceId)}awakeComEvent(t){t.awake()}destroyComEvent(t){t.destroy()}update(){const t=this._queues[InstanceQueueIndex.UPDATE],e=EntityCenter.getInst();for(let s=t.length-1;s>=0;s--){const n=t[s],i=e.get(n);i?i.isDisposed?t.splice(s,1):i.update():t.splice(s,1)}}lateUpdate(){const t=this._queues[InstanceQueueIndex.LATE_UPDATE],e=EntityCenter.getInst();for(let s=t.length-1;s>=0;s--){const n=t[s],i=e.get(n);i?i.isDisposed?t.splice(s,1):i.lateUpdate():t.splice(s,1)}}}!function(t){t[t.NONE=0]="NONE",t[t.IS_FROM_POOL=1]="IS_FROM_POOL",t[t.IS_REGISTER=2]="IS_REGISTER",t[t.IS_COMPONENT=4]="IS_COMPONENT",t[t.IS_CREATED=8]="IS_CREATED",t[t.IS_NEW=16]="IS_NEW"}(EntityStatus||(EntityStatus={}));class Entity{constructor(){this._status=EntityStatus.NONE}get parent(){return this._parent}set parent(t){if(null==t)throw new Error(`cant set parent null: ${this.constructor.name}`);if(t==this)throw new Error(`cant set parent self: ${this.constructor.name}`);if(null==t.domain)throw new Error(`cant set parent because parent domain is null: ${this.constructor.name} ${t.constructor.name}`);if(null!=this._parent){if(this._parent==t)throw new Error(`重复设置了Parent: ${this.constructor.name} parent: ${this._parent.constructor.name}`);this._parent.removeFromChildren(this)}this._parent=t,this.isComponent=!1,this._parent.addToChildren(this),this.domain=this.parent.domain}get domain(){return this._domain}set domain(t){if(null==t)throw new Error(`domain cant set null: ${this.constructor.name}`);if(this._domain==t)return;const e=this._domain;if(this._domain=t,null==e&&(this.instanceId=IdGenerator.getInst().generateInstanceId(),this.isRegister=!0),null!=this._children)for(const[t,e]of this._children.entries())e.domain=this._domain;if(null!=this._components)for(const[t,e]of this._components.entries())e.domain=this._domain;this.isCreated||(this.isCreated=!0)}get isDisposed(){return 0n==this.instanceId}get children(){return this._children??(this._children=ObjectPool.getInst().fetch(Map))}get components(){return this._components??(this._components=ObjectPool.getInst().fetch(Map))}get isFromPool(){return(this._status&EntityStatus.IS_FROM_POOL)==EntityStatus.IS_FROM_POOL}set isFromPool(t){t?this._status|=EntityStatus.IS_FROM_POOL:this._status&=~EntityStatus.IS_FROM_POOL}get isComponent(){return(this._status&EntityStatus.IS_COMPONENT)==EntityStatus.IS_COMPONENT}set isComponent(t){t?this._status|=EntityStatus.IS_COMPONENT:this._status&=~EntityStatus.IS_COMPONENT}get isCreated(){return(this._status&EntityStatus.IS_CREATED)==EntityStatus.IS_CREATED}set isCreated(t){t?this._status|=EntityStatus.IS_CREATED:this._status&=~EntityStatus.IS_CREATED}get isNew(){return(this._status&EntityStatus.IS_NEW)==EntityStatus.IS_NEW}set isNew(t){t?this._status|=EntityStatus.IS_NEW:this._status&=~EntityStatus.IS_NEW}get isRegister(){return(this._status&EntityStatus.IS_REGISTER)==EntityStatus.IS_REGISTER}set isRegister(t){if(this.isRegister!=t)if(t?this._status|=EntityStatus.IS_REGISTER:this._status&=~EntityStatus.IS_REGISTER,t){const t=this;EntityCenter.getInst().add(t),EntityLifiCycleMgr.getInst().registerSystem(t)}else EntityCenter.getInst().remove(this.instanceId)}set componentParent(t){if(null==t)throw new Error(`cant set parent null: ${this.constructor.name}`);if(t==this)throw new Error(`cant set parent self: ${this.constructor.name}`);if(null==t.domain)throw new Error(`cant set parent because parent domain is null: ${this.constructor.name} ${t.constructor.name}`);if(null!=this.parent){if(this.parent==t)throw new Error(`重复设置了Parent: ${this.constructor.name} parent: ${this.parent.constructor.name}`);this.parent.removeFromComponents(this)}this._parent=t,this.isComponent=!0,this._parent.addToComponents(this),this.domain=this.parent.domain}addCom(t,e){return t instanceof Entity?this.addComByEntity(t):this.addComByType(t,e)}tryAddCom(t){let e=this.getCom(t);return null==e&&(e=this.addCom(t)),e}addComByEntity(t){const e=t.constructor;if(null!=this._components&&this._components.has(e))throw new Error(`entity already has component: ${e.name}`);return t.componentParent=this,t}addComByType(t,e=!1){if(null!=this._components&&this._components.has(t))throw new Error(`entity already has component: ${t.name}`);const s=this.create(t,e);return s.id=this.id,s.componentParent=this,s.awake&&EntityLifiCycleMgr.getInst().awakeComEvent(s),s}addChild(t,e){return t instanceof Entity?this.addChildByEntity(t):this.addChildByType(t,e)}addChildWithId(t,e,s=!1){const n=this.create(t,s);return n.id=e,n.parent=this,n.awake&&EntityLifiCycleMgr.getInst().awakeComEvent(n),n}addChildByEntity(t){return t.parent=this,t}addChildByType(t,e=!1){const s=this.create(t,e);return s.id=IdGenerator.getInst().generateId(),s.parent=this,s.awake&&EntityLifiCycleMgr.getInst().awakeComEvent(s),s}create(t,e){let s;return s=e?ObjectPool.getInst().fetch(t):new t,s.isFromPool=e,s.isCreated=!0,s.isNew=!0,s.id=0n,s}removeFromChildren(t){null!=this._children&&(this._children.delete(t.id),0==this._children.size&&(ObjectPool.getInst().recycle(this._children),this._children=null))}removeFromComponents(t){null!=this._components&&(this._components.delete(t.constructor),0==this._components.size&&(ObjectPool.getInst().recycle(this._components),this._components=null))}addToComponents(t){this.components.set(t.constructor,t)}addToChildren(t){if(this.children.has(t.id))throw new Error(`entity already has child: ${t.id}`);this.children.set(t.id,t)}getCom(t){if(null==this._components)return null;const e=this._components.get(t);return e||null}removeCom(t){if(this.isDisposed)return;if(null==this._components)return;const e=this.getCom(t);null!=e&&(this.removeFromComponents(e),e.dispose())}getParent(t){return this.parent}getChild(t,e){if(null==this._children)return null;return this._children.get(e)}removeChild(t){if(null==this._children)return;const e=this._children.get(t);e&&(this._children.delete(t),e.dispose())}dispose(){if(!this.isDisposed){if(this.isRegister=!1,this.instanceId=0n,null!=this._children){for(const[t,e]of this._children.entries())e.dispose();this._children.clear(),ObjectPool.getInst().recycle(this._children),this._children=null}if(null!=this._components){for(const[t,e]of this._components.entries())e.dispose();this._components.clear(),ObjectPool.getInst().recycle(this._components),this._components=null}this.destroy&&EntityLifiCycleMgr.getInst().destroyComEvent(this),this._domain=null,null==this._parent||this._parent.isDisposed||(this.isComponent?this._parent.removeCom(this.getType()):this._parent.removeFromChildren(this)),this._parent=null,this.isFromPool&&ObjectPool.getInst().recycle(this),this._status=EntityStatus.NONE}}domainScene(){return this.domain}getType(){return this.constructor}}class Scene extends Entity{set domain(t){this._domain=t}get domain(){return this._domain}set parent(t){null!=t&&(this._parent=t,this._parent.children.set(this.id,this))}init(t){this.id=t.id,this.instanceId=t.instanceId,this.sceneType=t.sceneType,this.name=t.name,this.parent=t.parent,this.isCreated=!0,this.isNew=!0,this.domain=this,this.isRegister=!0,coreLog("scene create sceneType = {0}, name = {1}, id = {2}",this.sceneType,this.name,this.id)}}!function(t){t.NONE="NONE",t.PROCESS="PROCESS",t.CLIENT="CLIENT",t.CURRENT="CURRENT"}(SceneType||(SceneType={}));class RecycleObj{constructor(){this._isRecycle=!1}static create(t){const e=ObjectPool.getInst().fetch(this);return t&&Object.assign(e,t),e._isRecycle=!0,e}dispose(){this._isRecycle&&ObjectPool.getInst().recycle(this)}}class AEvent extends RecycleObj{}class BeforeSingletonAdd extends AEvent{}class AfterSingletonAdd extends AEvent{}class BeforeProgramInit extends AEvent{}class AfterProgramInit extends AEvent{}class BeforeProgramStart extends AEvent{}class AfterProgramStart extends AEvent{}class DecoratorCollector{constructor(){this._decorators=new Map}static get inst(){return null==DecoratorCollector._inst&&(DecoratorCollector._inst=new DecoratorCollector),DecoratorCollector._inst}add(t,...e){let s=this._decorators.get(t);s||(s=[],this._decorators.set(t,s)),s.push(e)}get(t){return this._decorators.get(t)||[]}}const EventDecoratorType="EventDecoratorType";function EventDecorator(t,e){return function(s){null==e&&console.error("EventDecorator必须要传 sceneType"),DecoratorCollector.inst.add(EventDecoratorType,t,s,e)}}class EventInfo{constructor(t,e){this.eventHandler=t,this.sceneType=e}}class MoyeEventCenter{constructor(){this.allEvents=new Map}static get inst(){return null==this._inst&&(this._inst=new MoyeEventCenter,this._inst.reloadEvent()),this._inst}reloadEvent(){const t=DecoratorCollector.inst.get(EventDecoratorType);this.allEvents.clear();for(const e of t){const t=e[0],s=e[1],n=e[2];let i=this.allEvents.get(t);i||(i=[],this.allEvents.set(t,i)),i.push(new EventInfo(new s,n))}}publish(t){const e=this.allEvents.get(t.constructor);if(e){for(let s=0;s<e.length;s++){e[s].eventHandler.handle(null,t)}t.dispose()}}}class Task extends Promise{static create(t){let e;const s=new Task((t=>{e=t}));return s._resolve=e,s}setResult(t){if(!this._resolve)throw new Error("setResult but task has been disposed");this._resolve(t),this.dispose()}constructor(t){super(t)}dispose(){this._resolve=null}}class Game{static addSingleton(t,e=!0){if(Game._singletonMap.has(t))throw new Error(`already exist singleton: ${t.name}`);e&&MoyeEventCenter.inst.publish(BeforeSingletonAdd.create({singletonType:t}));const s=new t;t._inst=s,Game._singletonMap.set(t,s),Game._singletons.push(s);const n=s;return n.awake&&n.awake(),Game._destroys.push(n),n.update&&Game._updates.push(n),n.lateUpdate&&Game._lateUpdates.push(n),e&&MoyeEventCenter.inst.publish(AfterSingletonAdd.create({singletonType:t})),s}static async waitFrameFinish(){const t=Task.create();Game._frameFinishTaskQueue.push(t),await t}static update(){for(let t=0;t<Game._updates.length;t++){const e=Game._updates[t];e.isDisposed||e.update()}}static lateUpdate(){for(let t=0;t<Game._lateUpdates.length;t++){const e=Game._lateUpdates[t];e.isDisposed||e.lateUpdate()}}static frameFinishUpdate(){const t=Game._frameFinishTaskQueue.length;if(0!=t){for(let e=0;e<t;e++){Game._frameFinishTaskQueue[e].setResult()}Game._frameFinishTaskQueue=[]}}static dispose(){for(let t=Game._singletons.length-1;t>=0;t--){const e=Game._singletons[t];e.isDisposed||e._onPreDestroy()}}}Game._singletonMap=new Map,Game._singletons=[],Game._destroys=[],Game._updates=[],Game._lateUpdates=[],Game._frameFinishTaskQueue=[];class EventSystem extends Singleton{async publishAsync(t,e){const s=MoyeEventCenter.inst.allEvents.get(e.constructor);if(!s)return;const n=[];for(let i=0;i<s.length;i++){const r=s[i];r.sceneType!=t.sceneType&&"None"!=r.sceneType||n.push(r.eventHandler.handleAsync(t,e))}await Promise.all(n),e.dispose()}publish(t,e){const s=MoyeEventCenter.inst.allEvents.get(e.constructor);if(s){for(let n=0;n<s.length;n++){const i=s[n];i.sceneType!=t.sceneType&&"None"!=i.sceneType||i.eventHandler.handle(t,e)}e.dispose()}}}var __decorate=function(t,e,s,n){var i,r=arguments.length,o=r<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,s):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,s,n);else for(var a=t.length-1;a>=0;a--)(i=t[a])&&(o=(r<3?i(o):r>3?i(e,s,o):i(e,s))||o);return r>3&&o&&Object.defineProperty(e,s,o),o};const{ccclass:ccclass,property:property}=_decorator;let MoyeRuntime=class extends Component{start(){director.addPersistRootNode(this.node)}update(t){Game.update()}lateUpdate(t){Game.lateUpdate(),Game.frameFinishUpdate()}onDestroy(){Game.dispose()}};MoyeRuntime=__decorate([ccclass("MoyeRuntime")],MoyeRuntime);class Root extends Singleton{get scene(){return this._scene}awake(){const t=new Scene;t.init({id:0n,sceneType:SceneType.PROCESS,name:"Process",instanceId:IdGenerator.getInst().generateInstanceId()}),this._scene=t}}class Program{static init(t){MoyeEventCenter.inst.publish(new BeforeProgramInit),Game.addSingleton(ObjectPool,!1),Game.addSingleton(Options),Game.addSingleton(Logger),Game.addSingleton(EventSystem),Game.addSingleton(TimeInfo),Game.addSingleton(IdGenerator),Game.addSingleton(EntityCenter),Game.addSingleton(EntityLifiCycleMgr),Game.addSingleton(Root),t.addComponent(MoyeRuntime),MoyeEventCenter.inst.publish(new AfterProgramInit)}static start(){MoyeEventCenter.inst.reloadEvent(),MoyeEventCenter.inst.publish(new BeforeProgramStart),MoyeEventCenter.inst.publish(new AfterProgramStart)}}async function safeCall(t){try{return await t}catch(t){coreError(t?.stack)}}class AEventHandler{async handleAsync(t,e){try{await this.run(t,e)}catch(t){t instanceof Error?coreError(t.stack):coreError(t)}}handle(t,e){try{const s=this.run(t,e);s instanceof Promise&&(coreWarn("{0}的run方法是异步的, 请尽量不要用publish来通知",this.constructor.name),safeCall(s))}catch(t){t instanceof Error?coreError(t.stack):coreError(t)}}}export{AEvent,AEventHandler,AfterProgramInit,AfterProgramStart,AfterSingletonAdd,BeforeProgramInit,BeforeProgramStart,BeforeSingletonAdd,DecoratorCollector,Entity,EntityCenter,EventDecorator,EventDecoratorType,EventSystem,Game,IdGenerator,IdStruct,InstanceIdStruct,JsHelper,Logger,ObjectPool,Options,Program,RecycleObj,Scene,SceneType,Singleton,TimeInfo,error,log,safeCall,warn};