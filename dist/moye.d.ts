// Generated by dts-bundle-generator v8.0.1

import { Asset, AssetManager, Component, EventTouch, Material, Node, SpriteAtlas, SpriteFrame, UIRenderer, UITransform } from 'cc';

/**
 * 构造函数
 */
export interface Type<T = any> extends Function {
	new (...args: any[]): T;
}
export interface ISceneInitArgs {
	id: bigint;
	instanceId?: bigint;
	sceneType: string;
	name: string;
	parent?: Entity;
}
export declare class Scene extends Entity {
	name: string;
	sceneType: string;
	set domain(value: Entity);
	get domain(): Entity;
	set parent(value: Entity);
	get parent(): Entity;
	init(args: ISceneInitArgs): void;
}
export declare abstract class Entity {
	get parent(): Entity;
	set parent(value: Entity);
	get domain(): Entity;
	set domain(value: Entity);
	instanceId: bigint;
	id: bigint;
	get isDisposed(): boolean;
	get children(): Map<bigint, Entity>;
	get components(): Map<Type<Entity>, Entity>;
	protected _domain: Entity;
	private _children;
	private _components;
	protected _parent: Entity;
	private _status;
	private get isFromPool();
	private set isFromPool(value);
	private get isComponent();
	private set isComponent(value);
	protected get isCreated(): boolean;
	protected set isCreated(value: boolean);
	protected get isNew(): boolean;
	protected set isNew(value: boolean);
	protected get isRegister(): boolean;
	protected set isRegister(value: boolean);
	private set componentParent(value);
	addCom(component: Entity): Entity;
	addCom<T extends Entity>(type: Type<T>): T;
	addCom<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	/**
	 * if not exist com will add new
	 * @param type
	 * @returns
	 */
	tryAddCom<T extends Entity>(type: Type<T>): T;
	private addComByEntity;
	private addComByType;
	addChild(entity: Entity): Entity;
	addChild<T extends Entity>(type: Type<T>): T;
	addChild<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	addChildWithId<T extends Entity>(type: Type<T>, id: bigint, isFromPool?: boolean): T;
	private addChildByEntity;
	private addChildByType;
	private create;
	private removeFromChildren;
	private removeFromComponents;
	private addToComponents;
	private addToChildren;
	getCom<K extends Entity>(type: new () => K): K;
	removeCom<T extends Entity>(type: Type<T>): T;
	getParent<T extends Entity>(type: Type<T>): T;
	getChild<T extends Entity>(type: Type<T>, id: bigint): T;
	removeChild(id: bigint): void;
	dispose(): void;
	domainScene(): Scene;
	getType(): Type;
	protected awake?(): void;
	protected update?(): void;
	protected lateUpdate?(): void;
	protected destroy?(): void;
}
export declare enum SceneType {
	NONE = "NONE",
	PROCESS = "PROCESS",
	CLIENT = "CLIENT",
	CURRENT = "CURRENT"
}
/**
 * 单例基类
 */
export declare abstract class Singleton {
	private static _inst;
	private _isDisposed;
	static get<T extends Singleton>(this: new () => T): T;
	get isDisposed(): boolean;
	dispose(): void;
	protected awake?(): void;
	/**
	 *
	 * @param dt ms
	 */
	protected update?(dt: number): void;
	/**
	 *
	 * @param dt ms
	 */
	protected lateUpdate?(dt: number): void;
	protected destroy?(): void;
	private _onPreDestroy;
}
/**
 * 保存根节点
 */
export declare class Root extends Singleton {
	get scene(): Scene;
	private _scene;
	awake(): void;
}
export interface IEntity {
	instanceId: bigint;
	isDisposed: boolean;
	awake(): void;
	update(): void;
	lateUpdate(): void;
	destroy(): void;
}
export declare class EntityCenter extends Singleton {
	private _allEntities;
	add(entity: IEntity): void;
	remove(instanceId: bigint): void;
	get(instanceId: bigint): IEntity;
}
export declare class ObjectPool extends Singleton {
	private _pool;
	fetch<T>(type: Type<T>): T;
	recycle(obj: object): void;
}
/**
 * 可回收对象
 */
export declare abstract class RecycleObj {
	private _isRecycle;
	/**
	 * 通过对象池创建
	 * @param this
	 * @param values
	 * @returns
	 */
	static create<T extends RecycleObj>(this: Type<T>, values?: Partial<T>): T;
	/**
	 * 如果是通过create方法创建的
	 * 那么dispose会回收到对象池
	 */
	dispose(): void;
}
export interface ILog {
	log(str: string): void;
	warn(str: string): void;
	error(str: string): void;
}
/**
 * Logger
 */
export declare class Logger extends Singleton {
	set iLog(value: ILog);
	static readonly LOG_LEVEL = 1;
	static readonly WARN_LEVEL = 2;
	private _logInst;
	private get _iLog();
	log(str: string, ...args: any[]): void;
	warn(str: string, ...args: any[]): void;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	error(str: string, ...args: any[]): void;
	private checkLogLevel;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreLog;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreWarn;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	private coreError;
}
/**
 * ```
 * log("hello {0}", "world") => hello world
 * log("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
 * log("hello {{qaq}} {0}", "world") => hello {qaq} world
 * ```
 * @param str
 * @param args
 */
export declare function log(str: string, ...args: any[]): void;
/**
 * ```
 * log("hello {0}", "world") => hello world
 * log("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
 * log("hello {{qaq}} {0}", "world") => hello {qaq} world
 * ```
 * @param str
 * @param args
 */
export declare function warn(str: string, ...args: any[]): void;
/**
 * ```
 * log("hello {0}", "world") => hello world
 * log("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
 * log("hello {{qaq}} {0}", "world") => hello {qaq} world
 * ```
 * @param str
 * @param args
 */
export declare function error(str: string, ...args: any[]): void;
export declare class IdGenerator extends Singleton {
	generateInstanceId(): bigint;
	generateId(): bigint;
}
export declare class IdStruct {
	private static _lastTime;
	private static _idCount;
	private static _inst;
	private static get inst();
	time: bigint;
	process: bigint;
	value: bigint;
	result: bigint;
	static generate(): bigint;
	static convertToId(time: number, process: number, value: number): bigint;
	/**
	 * convert id to 3 args
	 * not reference return value
	 * @param id bigint
	 * @returns
	 */
	static parseId(id: bigint): IdStruct;
	private static timeSinceEpoch;
	/**
	 * convert id to 3 args
	 * @param id bigint
	 * @returns
	 */
	initById(id: bigint): this;
	init(time: number, process: number, value: number): this;
	private updateResult;
}
export declare class InstanceIdStruct {
	private static _lastTime;
	private static _idCount;
	private static _inst;
	private static get inst();
	time: bigint;
	value: bigint;
	result: bigint;
	static generate(): bigint;
	static convertToId(time: number, value: number): bigint;
	/**
	 * convert id to 2 args
	 * not reference return value
	 * @param id bigint
	 * @returns
	 */
	static parseId(id: bigint): InstanceIdStruct;
	private static timeSinceEpoch;
	/**
	 * convert id to 3 args
	 * @param id bigint
	 * @returns
	 */
	initById(id: bigint): this;
	init(time: number, value: number): this;
	private updateResult;
}
export declare class Program {
	static init(rootNode: Node): void;
	/**
	 * 确保所有脚本已经加载之后调用start
	 */
	static start(): void;
}
export declare class Game {
	private static _singletonMap;
	private static _singletons;
	private static _destroys;
	private static _updates;
	private static _lateUpdates;
	private static _frameFinishTaskQueue;
	static addSingleton<T extends Singleton>(singletonType: new () => T, isNotify?: boolean): T;
	static waitFrameFinish(): Promise<void>;
	static update(dt: number): void;
	static lateUpdate(dt: number): void;
	static frameFinishUpdate(): void;
	static dispose(): void;
}
export interface IScene {
	sceneType: string;
}
export type T = Scene;
export declare const EventHandlerTag = "EventHandler";
export declare abstract class AEventHandler<A> {
	protected abstract run(scene: T, args: A): any;
	handleAsync(scene: IScene, a: A): Promise<void>;
	handle(scene: IScene, a: A): void;
}
/**
 * 事件基类
 */
export declare abstract class AEvent extends RecycleObj {
}
/**
 * before singleton add
 *
 * NOTE: scene is null
 */
export declare class BeforeSingletonAdd extends AEvent {
	singletonType: Type<Singleton>;
}
/**
 * after singleton add
 *
 * NOTE: scene is null
 */
export declare class AfterSingletonAdd extends AEvent {
	singletonType: Type<Singleton>;
}
/**
 * before program init
 *
 * NOTE: scene is null
 */
export declare class BeforeProgramInit extends AEvent {
}
/**
 * after program init
 *
 * NOTE: scene is null
 */
export declare class AfterProgramInit extends AEvent {
}
/**
 * before program start
 *
 * NOTE: scene is null
 */
export declare class BeforeProgramStart extends AEvent {
}
/**
 * after program start,
 * you can listen this event and start your game logic
 *
 * NOTE: scene is null
 */
export declare class AfterProgramStart extends AEvent {
}
/**
 * 创建ClientScene后
 */
export declare class AfterCreateClientScene extends AEvent {
}
/**
 * 创建CurrentScene后
 */
export declare class AfterCreateCurrentScene extends AEvent {
}
export declare const EventDecoratorType = "EventDecoratorType";
/**
 * 事件装饰器
 * @param event
 * @param sceneType
 * @returns
 */
export declare function EventDecorator(event: Type<AEvent>, sceneType: string): (target: Type) => void;
export declare class EventSystem extends Singleton {
	publishAsync<T extends AEvent>(scene: IScene, eventType: T): Promise<void>;
	/**
	 * 一定要确保事件处理函数不是异步方法
	 * 否则会导致事件处理顺序不一致和错误无法捕获
	 * @param scene
	 * @param eventType
	 * @returns
	 */
	publish<T extends AEvent>(scene: IScene, eventType: T): void;
}
export declare class TimeInfo extends Singleton {
	/**
	 * server time - client time
	 */
	serverMinusClientTime: number;
	/**
	 * 上一帧的增量时间，以毫秒为单位
	 */
	deltaTime: number;
	protected awake(): void;
	/**
	 * Returns the number of milliseconds elapsed since midnight, January 1, 1970 Universal Coordinated Time (UTC).
	 * @returns
	 */
	clientNow(): number;
	serverNow(): number;
	protected update(dt: number): void;
}
export declare class TimeHelper {
	static readonly oneDay: number;
	static readonly oneHour: number;
	static readonly oneMinute: number;
	static clientNow(): number;
	static clientNowSeconds(): number;
	static serverNow(): number;
}
export declare class Options extends Singleton {
	/**
	 * 是否是服务端
	 */
	readonly isServer: boolean;
	/**
	 * log等级 越低输出信息越多
	 * 不能控制框架层的输出
	 */
	logLevel: number;
	/**
	 * 是否开发阶段
	 */
	develop: boolean;
}
export declare class JsHelper {
	static getMethodName(): string;
	static getRootDirName(path: string): string;
	static sleep(ms: number): Promise<void>;
	static isNullOrEmpty(str: string): boolean;
	static getStringHashCode(str: string): number;
	static modeString(str: string, mode: number): number;
	static powBigInt(base: bigint, exp: bigint): bigint;
	/**
	 * 格式化字符串
	 * @param str 包含有 0 个或者多个格式符的字符串
	 * @param args
	 * @returns 格式化后的新字符串
	 * @performance 性能是+号拼接10分之1, 也就是比较慢, 要注意性能
	 * ```
	 * formatStr("hello {0}", "world") => hello world
	 * formatStr("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
	 * formatStr("hello {{qaq}} {0}", "world") => hello {qaq} world
	 * ```
	 */
	static formatStr(str: string, ...args: any[]): string;
}
/**
 * 这个方法执行一个promise，如果promise出现异常，会打印异常信息
 * @param promise
 * @returns
 */
export declare function safeCall(promise: Promise<any>): Promise<any>;
export declare class DecoratorCollector {
	private static _inst;
	static get inst(): DecoratorCollector;
	private _decorators;
	add(decoratorType: string, ...args: any[]): void;
	get(decoratorType: string): Array<any>;
}
export type Action<T = any> = () => T;
export type ActionAnyArgs<T = any> = (...args: any) => T;
export declare const CancellationTokenTag = "CancellationToken";
/**
 * cancel token
 */
export declare class CancellationToken {
	private _actions;
	/**
	 * add one cancel action
	 * @param callback 添加取消动作
	 * @returns
	 */
	add(callback: Action): void;
	remove(callback: Action): void;
	/**
	 * 执行取消动作
	 * @returns
	 */
	cancel(): void;
	isCancel(): boolean;
	private invoke;
}
export declare class TimerMgr extends Singleton {
	private _timerMap;
	private _timers;
	/**
	 * 不断重复的定时器
	 * @param interval ms
	 * @param callback
	 * @param immediately 是否立即执行
	 * @returns
	 */
	newRepeatedTimer(interval: number, callback: Action, immediately?: boolean): number;
	/**
	 *
	 * @param timeout ms
	 * @param callback
	 * @returns
	 */
	newOnceTimer(timeout: number, callback: Action): number;
	newFrameTimer(callback: Action): number;
	remove(id: number): boolean;
	/**
	 * 浏览器上会有一个问题
	 * 就是cocos的update后台不执行,但是js脚本依然执行，导致大量的timer没回收
	 * 暂时不处理这个问题 应该没什么影响
	 */
	protected update(): void;
	/**
	 *
	 * @param time ms
	 * @param cancellationToken
	 * @returns
	 */
	waitAsync(time: number, cancellationToken?: CancellationToken): Promise<void>;
}
export declare class Task<T = any> extends Promise<T> {
	private _resolve;
	/**
	 * 创建一个新的task
	 * @param type
	 * @returns
	 */
	static create<T = any>(type?: Type<T>): Task<T>;
	setResult(result?: T): void;
	/**
	 * 不允许直接new
	 * @param executor
	 */
	private constructor();
	private dispose;
}
export declare const CoroutineLockTag = "CoroutineLock";
export declare class CoroutineLockItem {
	key: string;
	task: Task;
	private _timeoutInfo;
	private _timerId;
	init(key: string): void;
	/**
	 * timeout tips
	 * @param timeout ms
	 * @param info
	 * @returns
	 */
	private setTimeout;
	private deleteTimeout;
	private timeout;
	dispose(): void;
}
export declare class CoroutineLock extends Singleton {
	private _lockMap;
	wait(lockType: string, key: string): Promise<CoroutineLockItem>;
	runNextLock(lock: CoroutineLockItem): void;
}
export declare class SceneFactory {
	static createClientScene(): Scene;
	static createCurrentScene(id: bigint, name: string): Scene;
}
/**
 * manage client scene
 */
export declare class SceneRefCom extends Entity {
	scene: Scene;
}
export interface Entity {
	currentScene(): Scene;
	clientScene(): Scene;
}
/**
 * 事件组件 可以发送事件给监听的对象
 * 不允许取消订阅
 */
export declare class EventCom extends Entity {
	private _eventMap;
	protected destroy(): void;
	/**
	 * evtCom.subscribe(123, this.onEvent, this)
	 * handler不需要绑定entity 也就是不需要bind
	 * @param eventType
	 * @param handler
	 * @param entity
	 */
	subscribe(eventCode: number, handler: Function, entity: Entity): void;
	publish(eventCode: number, ...args: any[]): void;
}
export interface IColorLike {
	r: number;
	g: number;
	b: number;
	a: number;
	_val: number;
}
export interface IMat3Like {
	m00: number;
	m01: number;
	m02: number;
	m03: number;
	m04: number;
	m05: number;
	m06: number;
	m07: number;
	m08: number;
}
export interface IMat4Like {
	m00: number;
	m01: number;
	m02: number;
	m03: number;
	m04: number;
	m05: number;
	m06: number;
	m07: number;
	m08: number;
	m09: number;
	m10: number;
	m11: number;
	m12: number;
	m13: number;
	m14: number;
	m15: number;
}
export interface IQuatLike {
	x: number;
	y: number;
	z: number;
	w: number;
}
export interface IRectLike {
	x: number;
	y: number;
	width: number;
	height: number;
}
export interface ISizeLike {
	width: number;
	height: number;
}
export interface IVec2Like {
	x: number;
	y: number;
}
export interface IVec3Like {
	x: number;
	y: number;
	z: number;
}
export interface IVec4Like {
	x: number;
	y: number;
	z: number;
	w: number;
}
export type FloatArray = Float64Array | Float32Array;
export type IVec2 = IVec2Like | Readonly<IVec2Like>;
export type IVec3 = IVec3Like | Readonly<IVec3Like>;
export type IVec4 = IVec4Like | Readonly<IVec4Like>;
export type IMat3 = IMat3Like | Readonly<IMat3Like>;
export type IMat4 = IMat4Like | Readonly<IMat4Like>;
export type IRect = IRectLike | Readonly<IRectLike>;
export type IQuat = IQuatLike | Readonly<IQuatLike>;
export type IColor = IColorLike | Readonly<IColorLike>;
/**
 * @en Representation of 3D vectors and points.
 * @zh 三维向量。
 */
export declare class Vec3 {
	static UNIT_X: Readonly<Vec3>;
	static UNIT_Y: Readonly<Vec3>;
	static UNIT_Z: Readonly<Vec3>;
	static RIGHT: Readonly<Vec3>;
	static UP: Readonly<Vec3>;
	static FORWARD: Readonly<Vec3>;
	static ZERO: Readonly<Vec3>;
	static ONE: Readonly<Vec3>;
	static NEG_ONE: Readonly<Vec3>;
	/**
	 * @en return a Vec3 object with x = 0, y = 0, z = 0.
	 * @zh 将目标赋值为零向量
	 */
	static zero<Out extends IVec3Like>(out: Out): Out;
	/**
	 * @en Obtains a clone of the given vector object
	 * @zh 获得指定向量的拷贝
	 */
	static clone<Out extends IVec3Like>(a: Out): Vec3;
	/**
	 * @en Copy the target vector and save the results to out vector object
	 * @zh 复制目标向量
	 */
	static copy<Out extends IVec3Like, Vec3Like extends IVec3Like>(out: Out, a: Vec3Like): Out;
	/**
	 * @en Sets the out vector with the given x, y and z values
	 * @zh 设置向量值
	 */
	static set<Out extends IVec3Like>(out: Out, x: number, y: number, z: number): Out;
	/**
	 * @en Element-wise vector addition and save the results to out vector object
	 * @zh 逐元素向量加法
	 */
	static add<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Element-wise vector subtraction and save the results to out vector object
	 * @zh 逐元素向量减法
	 */
	static subtract<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Element-wise vector multiplication and save the results to out vector object
	 * @zh 逐元素向量乘法 (分量积)
	 */
	static multiply<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Element-wise vector division and save the results to out vector object
	 * @zh 逐元素向量除法
	 */
	static divide<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Rounds up by elements of the vector and save the results to out vector object
	 * @zh 逐元素向量向上取整
	 */
	static ceil<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Element-wise rounds down of the current vector and save the results to the out vector
	 * @zh 逐元素向量向下取整
	 */
	static floor<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Calculates element-wise minimum values and save to the out vector
	 * @zh 逐元素向量最小值
	 */
	static min<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Calculates element-wise maximum values and save to the out vector
	 * @zh 逐元素向量最大值
	 */
	static max<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Calculates element-wise round results and save to the out vector
	 * @zh 逐元素向量四舍五入取整
	 */
	static round<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Vector scalar multiplication and save the results to out vector object
	 * @zh 向量标量乘法
	 */
	static multiplyScalar<Out extends IVec3Like, Vec3Like extends IVec3Like>(out: Out, a: Vec3Like, b: number): Out;
	/**
	 * @en Element-wise multiplication and addition with the equation: a + b * scale
	 * @zh 逐元素向量乘加: A + B * scale
	 */
	static scaleAndAdd<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like, scale: number): Out;
	/**
	 * @en Calculates the euclidean distance of two vectors
	 * @zh 求两向量的欧氏距离
	 */
	static distance(a: IVec3Like, b: IVec3Like): number;
	/**
	 * @en Calculates the squared euclidean distance of two vectors
	 * @zh 求两向量的欧氏距离平方
	 */
	static squaredDistance(a: IVec3Like, b: IVec3Like): number;
	/**
	 * @en Calculates the length of the vector
	 * @zh 求向量长度
	 */
	static len(a: IVec3Like): number;
	/**
	 * @en Calculates the squared length of the vector
	 * @zh 求向量长度平方
	 */
	static lengthSqr(a: IVec3Like): number;
	/**
	 * @en Sets each element to its negative value
	 * @zh 逐元素向量取负
	 */
	static negate<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Sets each element to its inverse value, zero value will become Infinity
	 * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
	 */
	static invert<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Sets each element to its inverse value, zero value will remain zero
	 * @zh 逐元素向量取倒数，接近 0 时返回 0
	 */
	static invertSafe<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Sets the normalized vector to the out vector, returns a zero vector if input is a zero vector.
	 * @zh 归一化向量，输入零向量将会返回零向量。
	 */
	static normalize<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
	/**
	 * @en Calculates the dot product of the vector
	 * @zh 向量点积（数量积）
	 */
	static dot<Out extends IVec3Like>(a: Out, b: IVec3Like): number;
	/**
	 * @en Calculates the cross product of the vector
	 * @zh 向量叉积（向量积）
	 */
	static cross<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Calculates the linear interpolation between two vectors with a given ratio: A + t * (B - A)
	 * @zh 逐元素向量线性插值： A + t * (B - A)
	 */
	static lerp<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like, t: number): Out;
	/**
	 * @zh 球面线性插值。多用于插值两个方向向量。
	 * @en Spherical linear interpolation. Commonly used in interpolation between directional vectors.
	 * @param out @zh 输出向量。 @en Output vector.
	 * @param from @zh 起点向量。 @en Start vector.
	 * @param to @zh 终点向量。 @en Destination vector.
	 * @param t @zh 插值参数。@en Interpolation parameter.
	 * @returns `out`
	 * @description
	 * @zh
	 * - 如果 `from`、`to` 中任何一个接近零向量，则结果就是 `from` 到 `to` 线性插值的结果；
	 *
	 * - 否则，如果 `from`、`to` 方向刚好接近相反，
	 * 则结果向量是满足以下条件的一个向量：结果向量和两个输入向量的夹角之比是 `t`，其长度是 `from` 到 `to` 的长度线性插值的结果；
	 *
	 * - 否则，结果是从标准化后的 `from` 到 标准化后的 `to`
	 * 进行球面线性插值的结果乘以 `from` 到 `to` 的长度线性插值后的长度。
	 * @en
	 * - If either `from` or `to` is close to zero vector,
	 * the result would be the (non-spherical) linear interpolation result from `from` to `to`.
	 *
	 * - Otherwise, if `from` and `to` have almost opposite directions,
	 * the result would be such a vector so that:
	 * The angle ratio between result vector and input vectors is `t`,
	 * the length of result vector is the linear interpolation of lengths from `from` to `to`.
	 *
	 * - Otherwise, the result would be the spherical linear interpolation result
	 * from normalized `from` to normalized `to`,
	 * then scaled by linear interpolation of lengths from `from` to `to`.
	 */
	static slerp: <Out extends IVec3Like>(out: Out, from: Readonly<IVec3Like>, to: Readonly<IVec3Like>, t: number) => Out;
	/**
	 * @en Generates a uniformly distributed random vector points from center to the surface of the unit sphere
	 * @zh 生成一个在单位球体上均匀分布的随机向量
	 * @param scale vector length
	 */
	static random<Out extends IVec3Like>(out: Out, scale?: number): Out;
	/**
	 * @en Vector and fourth order matrix multiplication, will complete the vector with a fourth value as one
	 * @zh 向量与四维矩阵乘法，默认向量第四位为 1。
	 */
	static transformMat4<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat4Like): Out;
	/**
	 * @en Vector and fourth order matrix multiplication, will complete the vector with a fourth element as one
	 * @zh 向量与四维矩阵乘法，默认向量第四位为 0。
	 */
	static transformMat4Normal<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat4Like): Out;
	/**
	 * @en Vector and third order matrix multiplication
	 * @zh 向量与三维矩阵乘法
	 */
	static transformMat3<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat3Like): Out;
	/**
	 * @en Affine transformation vector
	 * @zh 向量仿射变换
	 */
	static transformAffine<Out extends IVec3Like>(out: Out, v: IVec3Like, m: IMat4Like): Out;
	/**
	 * @en Vector quaternion multiplication: q*a*q^{-1}.
	 * @zh 向量四元数乘法：q*a*q^{-1}。
	 */
	static transformQuat<Out extends IVec3Like>(out: Out, a: IVec3Like, q: IQuatLike): Out;
	/**
	 * @en Transforms the current vector with given scale, rotation and translation in order
	 * @zh 以缩放 -> 旋转 -> 平移顺序变换向量
	 */
	static transformRTS<Out extends IVec3Like>(out: Out, a: IVec3Like, r: IQuatLike, t: IVec3Like, s: IVec3Like): Out;
	/**
	 * @en Transforms the current vector with given scale, rotation and translation in reverse order
	 * @zh 以平移 -> 旋转 -> 缩放顺序逆变换向量
	 */
	static transformInverseRTS<Out extends IVec3Like>(out: Out, a: IVec3Like, r: IQuatLike, t: IVec3Like, s: IVec3Like): Out;
	/**
	 * @en Rotates the vector with specified angle around X axis
	 * @zh 绕 X 轴旋转向量指定弧度
	 * @param v rotation vector
	 * @param o center of rotation
	 * @param a radiance of rotation
	 */
	static rotateX<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
	/**
	 * @en Rotates the vector with specified angle around Y axis
	 * @zh 绕 Y 轴旋转向量指定弧度
	 * @param v rotation vector
	 * @param o center of rotation
	 * @param a radiance of rotation
	 */
	static rotateY<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
	/**
	 * @en Rotates the vector with specified angle around Z axis
	 * @zh 绕 Z 轴旋转向量指定弧度
	 * @param v rotation vector
	 * @param o center of rotation
	 * @param a radiance of rotation
	 */
	static rotateZ<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
	/**
	 * @en Rotates the vector with specified angle around any n axis
	 * @zh 绕任意 n 轴旋转向量指定弧度
	 * @param v rotation vector
	 * @param o center of rotation
	 * @param n axis of rotation
	 * @param a radiance of rotation
	 */
	static rotateN<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, n: IVec3Like, a: number): Out;
	/**
	 * @en Converts the given vector to an array
	 * @zh 向量转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, v: IVec3Like, ofs?: number): Out;
	/**
	 * @en Converts the given array to a vector
	 * @zh 数组转向量
	 * @param ofs Array Start Offset
	 */
	static fromArray<Out extends IVec3Like>(out: Out, arr: Array<number>, ofs?: number): Out;
	/**
	 * @en Check the equality of the two given vectors
	 * @zh 向量等价判断
	 */
	static strictEquals(a: IVec3Like, b: IVec3Like): boolean;
	/**
	 * @en Check whether the two given vectors are approximately equivalent
	 * @zh 排除浮点数误差的向量近似等价判断
	 */
	static equals(a: IVec3Like, b: IVec3Like, epsilon?: number): boolean;
	/**
	 * @en Calculates the radian angle between two vectors
	 * @zh 求两向量夹角弧度
	 */
	static angle(a: IVec3Like, b: IVec3Like): number;
	/**
	 * @en Calculates the projection vector on the specified plane
	 * @zh 计算向量在指定平面上的投影
	 * @param a projection vector
	 * @param n the normal line of specified plane
	 */
	static projectOnPlane<Out extends IVec3Like>(out: Out, a: IVec3Like, n: IVec3Like): Out;
	/**
	 * @en Calculates the projection on the specified vector
	 * @zh 计算向量在指定向量上的投影
	 * @param a projection vector
	 * @param b target vector
	 */
	static project<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
	/**
	 * @en Calculates a new position from current to target no more than `maxStep` distance.
	 * @zh 计算一个新位置从当前位置移动不超过 `maxStep` 距离到目标位置。
	 * @param current current position
	 * @param target target position
	 * @param maxStep maximum moving distance
	 */
	static moveTowards<Out extends IVec3Like>(out: Out, current: IVec3Like, target: IVec3Like, maxStep: number): Out;
	/**
	 * @zh 生成指定向量的一个正交单位向量。如果指定的向量 **精确地** 是零向量，则返回 **精确的** 零向量。
	 * @en Generates an unit vector orthogonal to specified vector.
	 * If the specified vector is **strictly** zero vector, the result is **strict** zero vector.
	 * @param out @zh 生成的向量。@en The generated vector.
	 * @param n @zh 输入向量。该向量 **不必** 是标准化的。 @en The input vector. **Need not** to be normalized.
	 * @returns `out`
	 */
	static generateOrthogonal<Out extends IVec3Like>(out: Out, n: Readonly<IVec3Like>): Out;
	/**
	 * @en x component.
	 * @zh x 分量。
	 */
	x: number;
	/**
	 * @en y component.
	 * @zh y 分量。
	 */
	y: number;
	/**
	 * @en z component.
	 * @zh z 分量。
	 */
	z: number;
	constructor(v: Vec3);
	constructor(x?: number, y?: number, z?: number);
	/**
	 * @en clone a Vec3 value
	 * @zh 克隆当前向量。
	 */
	clone(): Vec3;
	/**
	 * @en Set the current vector value with the given vector.
	 * @zh 设置当前向量使其与指定向量相等。
	 * @param other Specified vector
	 * @returns `this`
	 */
	set(other: Vec3): Vec3;
	/**
	 * @en Set the value of each component of the current vector.
	 * @zh 设置当前向量的具体分量值。
	 * @param x x value
	 * @param y y value
	 * @param z z value
	 * @returns `this`
	 */
	set(x?: number, y?: number, z?: number): Vec3;
	/**
	 * @en Check whether the vector approximately equals another one.
	 * @zh 判断当前向量是否在误差范围内与指定向量相等。
	 * @param other Specified vector
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	equals(other: Vec3, epsilon?: number): boolean;
	/**
	 * @en Check whether the vector approximately equals another one.
	 * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	equals3f(x: number, y: number, z: number, epsilon?: number): boolean;
	/**
	 * @en Check whether the current vector strictly equals another Vec3.
	 * @zh 判断当前向量是否与指定向量相等。
	 * @param other specified vector
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	strictEquals(other: Vec3): boolean;
	/**
	 * @en Check whether the current vector strictly equals another Vec3.
	 * @zh 判断当前向量是否与指定分量的向量相等。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	strictEquals3f(x: number, y: number, z: number): boolean;
	/**
	 * @en Transform to string with vector information.
	 * @zh 返回当前向量的字符串表示。
	 * @returns The string with vector information
	 */
	toString(): string;
	/**
	 * @en Calculate linear interpolation result between this vector and another one with given ratio.
	 * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
	 * @param to Target vector
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	lerp(to: Vec3, ratio: number): Vec3;
	/**
	 * @en Adds the current vector with another one and return this
	 * @zh 向量加法。将当前向量与指定向量的相加
	 * @param other specified vector
	 */
	add(other: Vec3): Vec3;
	/**
	 * @en Adds the current vector with another one and return this
	 * @zh 向量加法。将当前向量与指定分量的向量相加
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 */
	add3f(x: number, y: number, z: number): Vec3;
	/**
	 * @en Subtracts one vector from this, and returns this.
	 * @zh 向量减法。将当前向量减去指定向量的结果。
	 * @param other specified vector
	 */
	subtract(other: Vec3): Vec3;
	/**
	 * @en Subtracts one vector from this, and returns this.
	 * @zh 向量减法。将当前向量减去指定分量的向量
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 */
	subtract3f(x: number, y: number, z: number): Vec3;
	/**
	 * @en Multiplies the current vector with a number, and returns this.
	 * @zh 向量数乘。将当前向量数乘指定标量
	 * @param scalar scalar number
	 */
	multiplyScalar(scalar: number): Vec3;
	/**
	 * @en Multiplies the current vector with another one and return this
	 * @zh 向量乘法。将当前向量乘以与指定向量的结果赋值给当前向量。
	 * @param other specified vector
	 */
	multiply(other: Vec3): Vec3;
	/**
	 * @en Multiplies the current vector with another one and return this
	 * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 */
	multiply3f(x: number, y: number, z: number): Vec3;
	/**
	 * @en Element-wisely divides this vector with another one, and return this.
	 * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
	 * @param other specified vector
	 */
	divide(other: Vec3): Vec3;
	/**
	 * @en Element-wisely divides this vector with another one, and return this.
	 * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 */
	divide3f(x: number, y: number, z: number): Vec3;
	/**
	 * @en Sets each component of this vector with its negative value
	 * @zh 将当前向量的各个分量取反
	 */
	negative(): Vec3;
	/**
	 * @en Clamp the vector between minInclusive and maxInclusive.
	 * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
	 * @param minInclusive Minimum value allowed
	 * @param maxInclusive Maximum value allowed
	 * @returns `this`
	 */
	clampf(minInclusive: Vec3, maxInclusive: Vec3): Vec3;
	/**
	 * @en Calculates the dot product with another vector
	 * @zh 向量点乘。
	 * @param other specified vector
	 * @returns The result of calculates the dot product with another vector
	 */
	dot(other: Vec3): number;
	/**
	 * @en Calculates the cross product with another vector.
	 * @zh 向量叉乘。将当前向量左叉乘指定向量
	 * @param other specified vector
	 */
	cross(other: Vec3): Vec3;
	/**
	 * @en Returns the length of this vector.
	 * @zh 计算向量的长度（模）。
	 * @returns Length of vector
	 */
	length(): number;
	/**
	 * @en Returns the squared length of this vector.
	 * @zh 计算向量长度（模）的平方。
	 * @returns the squared length of this vector
	 */
	lengthSqr(): number;
	/**
	 * @en Normalize the current vector.
	 * @zh 将当前向量归一化
	 */
	normalize(): Vec3;
	/**
	 * @en Transforms the vec3 with a mat4. 4th vector component is implicitly '1'
	 * @zh 将当前向量视为 w 分量为 1 的四维向量，应用四维矩阵变换到当前矩阵
	 * @param matrix matrix to transform with
	 */
	transformMat4(matrix: Mat4): Vec3;
}
export declare function v3(other: Vec3): Vec3;
export declare function v3(x?: number, y?: number, z?: number): Vec3;
/**
 * @en Mathematical 3x3 matrix.
 * @zh 表示三维（3x3）矩阵。
 */
export declare class Mat3 {
	static IDENTITY: Readonly<Mat3>;
	/**
	 * @en Clone a matrix and save the results to out matrix
	 * @zh 获得指定矩阵的拷贝
	 */
	static clone<Out extends IMat3Like>(a: Out): Mat3;
	/**
	 * @en Copy content of a matrix into another and save the results to out matrix
	 * @zh 复制目标矩阵
	 */
	static copy<Out extends IMat3Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets the elements of a matrix with the given values and save the results to out matrix
	 * @zh 设置矩阵值
	 */
	static set<Out extends IMat3Like>(out: Out, m00: number, m01: number, m02: number, m03: number, m04: number, m05: number, m06: number, m07: number, m08: number): Out;
	/**
	 * @en Reset the out matrix to an identity matrix
	 * @zh 将目标赋值为单位矩阵
	 */
	static identity<Out extends IMat3Like>(out: Out): Out;
	/**
	 * @en Transposes a matrix and save the results to out matrix
	 * @zh 转置矩阵
	 */
	static transpose<Out extends IMat3Like>(out: Out, a: Out): Out;
	/**
	 * @en Inverts a matrix. When matrix is not invertible the matrix will be set to zeros.
	 * @zh 矩阵求逆，注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
	 */
	static invert<Out extends IMat3Like>(out: Out, a: Out): Out;
	/**
	 * @en Calculates the determinant of a matrix
	 * @zh 矩阵行列式
	 */
	static determinant<Out extends IMat3Like>(a: Out): number;
	/**
	 * @en Multiply two matrices explicitly and save the results to out matrix: a * b
	 * @zh 矩阵乘法：a * b
	 */
	static multiply<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Take the first third order of the fourth order matrix and multiply by the third order matrix: a * b
	 * @zh 取四阶矩阵的前三阶，与三阶矩阵相乘：a * b
	 */
	static multiplyMat4<Out extends IMat3Like>(out: Out, a: Out, b: IMat4Like): Out;
	/**
	 * @en Multiply a matrix with a translation vector given by a translation offset, first translate, then transform：a * T(v).
	 * @zh 在给定矩阵变换基础上加入位移变换，先位移，再变换，即a * T(v)。
	 */
	/**
	 * @deprecated since v3.8.0, the function name is misleading, please use translate instead.
	 */
	static transform<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): void;
	/**
	 * @en Multiply a matrix with a translation vector given by a translation offset, first translate, then transform：a * T(v).
	 * @zh 在给定矩阵变换基础上加入位移变换，先位移，再变换，即a * T(v)。
	 */
	static translate<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
	/**
	 * @en Multiply a matrix with a scale matrix given by a scale vector and save the results to out matrix, first scale, then transform：a * S(v).
	 * @zh 在给定矩阵变换基础上加入新缩放变换，先缩放，再变换，即a * S(v)。
	 */
	static scale<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
	/**
	 * @en Rotates the transform by the given angle and save the results into the out matrix, first rotate, then transform：a * R(rad).
	 * @zh 在给定矩阵变换基础上加入新旋转变换，先旋转，再变换，即a * R(rad)。
	 * @param rad radian of rotation
	 */
	static rotate<Out extends IMat3Like>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Copies the first third order matrix of a fourth order matrix to the out third order matrix
	 * @zh 取四阶矩阵的前三阶
	 */
	static fromMat4<Out extends IMat3Like>(out: Out, a: IMat4Like): Out;
	/**
	 * @en Sets a third order matrix with view direction and up direction. Then save the results to out matrix
	 * @zh 根据视口前方向和上方向计算矩阵
	 * @param view The view direction, it`s must be normalized.
	 * @param up The view up direction, it`s must be normalized, default value is (0, 1, 0).
	 */
	static fromViewUp<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, view: VecLike, up?: Vec3): Out;
	/**
	 * @en Sets the given matrix with a translation vector and save the results to out matrix
	 * @zh 计算位移矩阵
	 */
	static fromTranslation<Out extends IMat3Like, VecLike extends IVec2Like>(out: Out, v: VecLike): Out;
	/**
	 * @en Sets the given matrix with a scale vector and save the results to out matrix
	 * @zh 计算缩放矩阵
	 */
	static fromScaling<Out extends IMat3Like, VecLike extends IVec2Like>(out: Out, v: VecLike): Out;
	/**
	 * @en Sets the given matrix with a given angle and save the results to out matrix
	 * @zh 计算旋转矩阵
	 */
	static fromRotation<Out extends IMat3Like>(out: Out, rad: number): Out;
	/**
	 * @en Sets the given matrix with the given quaternion and save the results to out matrix
	 * @zh 根据四元数旋转信息计算矩阵
	 */
	static fromQuat<Out extends IMat3Like>(out: Out, q: IQuatLike): Out;
	/**
	 * @deprecated since v3.8.0, this function is too complicated, and should be split into several functions.
	 */
	/**
	 * @en Calculates the upper-left 3x3 matrix of a 4x4 matrix's inverse transpose
	 * @zh 计算指定四维矩阵的逆转置三维矩阵
	 */
	static inverseTransposeMat4<Out extends IMat3Like>(out: Out, a: IMat4Like): Out | null;
	/**
	 * @en Transform a matrix object to a flat array
	 * @zh 矩阵转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, m: IMat3Like, ofs?: number): Out;
	/**
	 * @en Generates or sets a matrix with a flat array
	 * @zh 数组转矩阵
	 * @param ofs Array Start Offset
	 */
	static fromArray<Out extends IMat3Like>(out: Out, arr: Array<number>, ofs?: number): Out;
	/**
	 * @en Adds two matrices and save the results to out matrix
	 * @zh 逐元素矩阵加法
	 */
	static add<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Subtracts matrix b from matrix a and save the results to out matrix
	 * @zh 逐元素矩阵减法
	 */
	static subtract<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Multiply each element of a matrix by a scalar number and save the results to out matrix
	 * @zh 矩阵标量乘法
	 */
	static multiplyScalar<Out extends IMat3Like>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Adds two matrices after multiplying each element of the second operand by a scalar number. And save the results to out matrix.
	 * @zh 逐元素矩阵标量乘加: A + B * scale
	 */
	static multiplyScalarAndAdd<Out extends IMat3Like>(out: Out, a: Out, b: Out, scale: number): Out;
	/**
	 * @en Returns whether the specified matrices are equal.
	 * @zh 矩阵等价判断
	 */
	static strictEquals<Out extends IMat3Like>(a: Out, b: Out): boolean;
	/**
	 * @en Returns whether the specified matrices are approximately equal.
	 * @zh 排除浮点数误差的矩阵近似等价判断
	 */
	static equals<Out extends IMat3Like>(a: Out, b: Out, epsilon?: number): boolean;
	/**
	 * @en Convert Matrix to euler angle, resulting angle y, z in the range of [-PI, PI],
	 *  x in the range of [-PI/2, PI/2], the rotation order is YXZ, first rotate around Y, then around X, and finally around Z.
	 * @zh 将矩阵转换成欧拉角, 返回角度 y,z 在 [-PI, PI] 区间内, x 在 [-PI/2, PI/2] 区间内，旋转顺序为 YXZ，即先绕Y旋转，再绕X，最后绕Z旋转。
	 */
	static toEuler<InType extends IMat3Like, VecLike extends IVec3Like>(matrix: InType, v: VecLike): boolean;
	/**
	 * matrix layout
	 * |m00  m03  m06|
	 * |m01  m04  m07|
	 * |m02  m05  m08|
	 */
	/**
	 * @en Value at column 0 row 0 of the matrix.
	 * @zh 矩阵第 0 列第 0 行的元素。
	 */
	m00: number;
	/**
	 * @en Value at column 0 row 1 of the matrix.
	 * @zh 矩阵第 0 列第 1 行的元素。
	 */
	m01: number;
	/**
	 * @en Value at column 0 row 2 of the matrix.
	 * @zh 矩阵第 0 列第 2 行的元素。
	 */
	m02: number;
	/**
	 * @en Value at column 1 row 0 of the matrix.
	 * @zh 矩阵第 1 列第 0 行的元素。
	 */
	m03: number;
	/**
	 * @en Value at column 1 row 1 of the matrix.
	 * @zh 矩阵第 1 列第 1 行的元素。
	 */
	m04: number;
	/**
	 * @en Value at column 1 row 2 of the matrix.
	 * @zh 矩阵第 1 列第 2 行的元素。
	 */
	m05: number;
	/**
	 * @en Value at column 2 row 0 of the matrix.
	 * @zh 矩阵第 2 列第 0 行的元素。
	 */
	m06: number;
	/**
	 * @en Value at column 2 row 1 of the matrix.
	 * @zh 矩阵第 2 列第 1 行的元素。
	 */
	m07: number;
	/**
	 * @en Value at column 2 row 2 of the matrix.
	 * @zh 矩阵第 2 列第 2 行的元素。
	 */
	m08: number;
	constructor(other: Mat3);
	constructor(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number);
	/**
	 * @en Clone a new matrix from the current matrix.
	 * @zh 克隆当前矩阵。
	 */
	clone(): Mat3;
	/**
	 * @en Sets the matrix with another one's value.
	 * @zh 设置当前矩阵使其与指定矩阵相等。
	 * @param other Specified matrix
	 * @return this
	 */
	set(other: Mat3): Mat3;
	/**
	 * @en Set the matrix with values of all elements
	 * @zh 设置当前矩阵指定元素值。
	 * @return this
	 */
	set(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number): Mat3;
	/**
	 * @en Returns whether the specified matrices are approximately equal.
	 * @zh 判断当前矩阵是否在误差范围内与指定矩阵相等。
	 * @param other Comparative matrix
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
	 */
	equals(other: Mat3, epsilon?: number): boolean;
	/**
	 * @en Returns whether the specified matrices are equal.
	 * @zh 判断当前矩阵是否与指定矩阵相等。
	 * @param other Comparative matrix
	 * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
	 */
	strictEquals(other: Mat3): boolean;
	/**
	 * @en Returns a string representation of a matrix.
	 * @zh 返回当前矩阵的字符串表示。
	 * @return The string representation of this matrix
	 */
	toString(): string;
	/**
	 * @en set the current matrix to an identity matrix.
	 * @zh 将当前矩阵设为单位矩阵。
	 * @return `this`
	 */
	identity(): Mat3;
	/**
	 * @en Transposes the current matrix.
	 * @zh 计算当前矩阵的转置矩阵。
	 */
	transpose(): Mat3;
	/**
	 * @en Inverts the current matrix. When matrix is not invertible the matrix will be set to zeros.
	 * @zh 计算当前矩阵的逆矩阵。注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
	 */
	invert(): Mat3;
	/**
	 * @en Calculates the determinant of the current matrix.
	 * @zh 计算当前矩阵的行列式。
	 * @return 当前矩阵的行列式。
	 */
	determinant(): number;
	/**
	 * @en Adds the current matrix and another matrix to the current matrix.
	 * @zh 矩阵加法。将当前矩阵与指定矩阵的相加，结果返回给当前矩阵。
	 * @param mat the second operand
	 */
	add(mat: Mat3): Mat3;
	/**
	 * @en Subtracts another matrix from the current matrix.
	 * @zh 计算矩阵减法。将当前矩阵减去指定矩阵的结果赋值给当前矩阵。
	 * @param mat the second operand
	 */
	subtract(mat: Mat3): Mat3;
	/**
	 * @en Multiply the current matrix with another matrix.
	 * @zh 矩阵乘法。将当前矩阵左乘指定矩阵的结果赋值给当前矩阵。
	 * @param mat the second operand
	 */
	multiply(mat: Mat3): Mat3;
	/**
	 * @en Multiply each element of the current matrix by a scalar number.
	 * @zh 矩阵数乘。将当前矩阵与指定标量的数乘结果赋值给当前矩阵。
	 * @param scalar amount to scale the matrix's elements by
	 */
	multiplyScalar(scalar: number): Mat3;
	/**
	 * @en Multiply the current matrix with a scale matrix given by a scale vector, that is M * S(vec).
	 * @zh 将当前矩阵左乘缩放矩阵的结果赋值给当前矩阵，缩放矩阵由各个轴的缩放给出，即M * S(vec)。
	 * @param vec vector to scale by
	 */
	scale(vec: Vec3): Mat3;
	/**
	 * @en Rotates the current matrix by the given angle, that is M * R(rad).
	 * @zh 将当前矩阵左乘旋转矩阵的结果赋值给当前矩阵，旋转矩阵由旋转轴和旋转角度给出，即M * R(rad)。
	 * @param rad radian of rotation
	 */
	rotate(rad: number): Mat3;
	/**
	 * @en Resets the current matrix from the given quaternion.
	 * @zh 重置当前矩阵的值，使其表示指定四元数表示的旋转变换。
	 * @param q The quaternion.
	 * @returns this
	 */
	fromQuat(q: Quat): Mat3;
}
/**
 * @en quaternion
 * @zh 四元数
 */
export declare class Quat {
	static IDENTITY: Readonly<Quat>;
	/**
	 * @en Obtain a copy of the given quaternion
	 * @zh 获得指定四元数的拷贝
	 */
	static clone<Out extends IQuatLike>(a: Out): Quat;
	/**
	 * @en Copy the given quaternion to the out quaternion
	 * @zh 复制目标四元数
	 */
	static copy<Out extends IQuatLike, QuatLike extends IQuatLike>(out: Out, a: QuatLike): Out;
	/**
	 * @en Sets the out quaternion with values of each component
	 * @zh 设置四元数值
	 */
	static set<Out extends IQuatLike>(out: Out, x: number, y: number, z: number, w: number): Out;
	/**
	 * @en Sets the out quaternion to an identity quaternion
	 * @zh 将目标赋值为单位四元数
	 */
	static identity<Out extends IQuatLike>(out: Out): Out;
	/**
	 * @en Sets the out quaternion with the shortest path orientation between two vectors, considering both vectors normalized
	 * @zh 设置四元数为两向量间的最短路径旋转，默认两向量都已归一化
	 */
	static rotationTo<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, a: VecLike, b: VecLike): Out;
	/**
	 * @en Gets the rotation axis and the arc of rotation from the quaternion
	 * @zh 获取四元数的旋转轴和旋转弧度
	 * @param outAxis output axis
	 * @param q input quaternion
	 * @return radian of rotation
	 */
	static getAxisAngle<Out extends IQuatLike, VecLike extends IVec3Like>(outAxis: VecLike, q: Out): number;
	/**
	 * @en Quaternion multiplication and save the results to out quaternion, that is a * b.
	 * @zh 四元数乘法，即a * b。
	 */
	static multiply<Out extends IQuatLike, QuatLike_1 extends IQuatLike, QuatLike_2 extends IQuatLike>(out: Out, a: QuatLike_1, b: QuatLike_2): Out;
	/**
	 * @en Quaternion scalar multiplication and save the results to out quaternion
	 * @zh 四元数标量乘法
	 */
	static multiplyScalar<Out extends IQuatLike>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Quaternion multiplication and addition: A + B * scale
	 * @zh 四元数乘加：A + B * scale
	 */
	static scaleAndAdd<Out extends IQuatLike>(out: Out, a: Out, b: Out, scale: number): Out;
	/**
	 * @en Sets the out quaternion to represent a radian rotation around x axis
	 * @zh 绕 X 轴旋转指定四元数
	 * @param rad radian of rotation
	 */
	static rotateX<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Sets the out quaternion to represent a radian rotation around y axis
	 * @zh 绕 Y 轴旋转指定四元数
	 * @param rad radian of rotation
	 */
	static rotateY<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Sets the out quaternion to represent a radian rotation around z axis
	 * @zh 绕 Z 轴旋转指定四元数
	 * @param rad radian of rotation
	 */
	static rotateZ<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Sets the out quaternion to represent a radian rotation around a given rotation axis in world space
	 * @zh 绕世界空间下指定轴旋转四元数
	 * @param axis axis of rotation, normalized by default
	 * @param rad radian of rotation
	 */
	static rotateAround<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, rot: Out, axis: VecLike, rad: number): Out;
	/**
	 * @en Sets the out quaternion to represent a radian rotation around a given rotation axis in local space
	 * @zh 绕本地空间下指定轴旋转四元数
	 * @param axis axis of rotation
	 * @param rad radian of rotation
	 */
	static rotateAroundLocal<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, rot: Out, axis: VecLike, rad: number): Out;
	/**
	 * @en Calculates the w component with xyz components, considering the given quaternion normalized
	 * @zh 根据 xyz 分量计算 w 分量，默认已归一化
	 */
	static calculateW<Out extends IQuatLike>(out: Out, a: Out): Out;
	/**
	 * @en Quaternion dot product (scalar product)
	 * @zh 四元数点积（数量积）
	 */
	static dot<Out extends IQuatLike>(a: Out, b: Out): number;
	/**
	 * @en Element by element linear interpolation: A + t * (B - A)
	 * @zh 逐元素线性插值： A + t * (B - A)
	 */
	static lerp<Out extends IQuatLike>(out: Out, a: Out, b: Out, t: number): Out;
	/**
	 * @en Spherical quaternion interpolation
	 * @zh 四元数球面插值
	 */
	static slerp<Out extends IQuatLike, QuatLike_1 extends IQuatLike, QuatLike_2 extends IQuatLike>(out: Out, a: QuatLike_1, b: QuatLike_2, t: number): Out;
	/**
	 * @en Spherical quaternion interpolation with two control points
	 * @zh 带两个控制点的四元数球面插值
	 * @param out the receiving quaternion
	 * @param a the first operand
	 * @param b the second operand
	 * @param c the third operand
	 * @param d the fourth operand
	 * @param t interpolation amount, in the range [0-1], between the two inputs
	 * @returns out
	 */
	static sqlerp<Out extends IQuatLike>(out: Out, a: Out, b: Out, c: Out, d: Out, t: number): Out;
	/**
	 * @en Sets the inverse of the given quaternion to out quaternion
	 * @zh 四元数求逆
	 */
	static invert<Out extends IQuatLike, QuatLike extends IQuatLike>(out: Out, a: QuatLike): Out;
	/**
	 * @en Conjugating a quaternion, it's equivalent to the inverse of the unit quaternion, but more efficient
	 * @zh 求共轭四元数，对单位四元数与求逆等价，但更高效
	 */
	static conjugate<Out extends IQuatLike>(out: Out, a: Out): Out;
	/**
	 * @en Calculates the length of the quaternion
	 * @zh 求四元数长度
	 */
	static len<Out extends IQuatLike>(a: Out): number;
	/**
	 * @en Calculates the squared length of the quaternion
	 * @zh 求四元数长度平方
	 */
	static lengthSqr<Out extends IQuatLike>(a: Out): number;
	/**
	 * @en Normalize the given quaternion, returns a zero quaternion if input is a zero quaternion.
	 * @zh 归一化四元数，输入零四元数将会返回零四元数。
	 */
	static normalize<Out extends IQuatLike>(out: Out, a: Out): Out;
	/**
	 * @en Calculated the quaternion represents the given coordinates, considering all given vectors are normalized and mutually perpendicular
	 * @zh 根据本地坐标轴朝向计算四元数，默认三向量都已归一化且相互垂直
	 */
	static fromAxes<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, xAxis: VecLike, yAxis: VecLike, zAxis: VecLike): Out;
	/**
	 * @en Calculates the quaternion with the up direction and the direction of the viewport
	 * @zh 根据视口的前方向和上方向计算四元数
	 * @param view The view direction, it`s must be normalized.
	 * @param up The view up direction, it`s must be normalized, default value is (0, 1, 0).
	 */
	static fromViewUp<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, view: VecLike, up?: Vec3): Out;
	/**
	 * @en Calculates the quaternion from a given rotary shaft and a radian rotation around it.
	 * @zh 根据旋转轴和旋转弧度计算四元数
	 */
	static fromAxisAngle<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, axis: VecLike, rad: number): Out;
	/**
	 * @en Calculates the quaternion with the three-dimensional transform matrix, considering no scale included in the matrix
	 * @zh 根据三维矩阵信息计算四元数，默认输入矩阵不含有缩放信息
	 */
	static fromMat3<Out extends IQuatLike>(out: Out, m: Mat3): Out;
	/**
	 * @en Calculates the quaternion with Euler angles, the rotation order is YZX, first rotate around Y, then around Z, and finally around X.
	 * @zh 根据欧拉角信息计算四元数，旋转顺序为 YZX，即先绕Y旋转，再绕Z，最后绕X旋转。
	 */
	static fromEuler<Out extends IQuatLike>(out: Out, x: number, y: number, z: number): Out;
	/**
	 * @en Calculates the quaternion with given 2D angle (0, 0, z).
	 * @zh 根据 2D 角度（0, 0, z）计算四元数
	 *
	 * @param out Output quaternion
	 * @param z Angle to rotate around Z axis in degrees.
	 */
	static fromAngleZ<Out extends IQuatLike>(out: Out, z: number): Out;
	/**
	 * @en This returns the X-axis vector of the quaternion
	 * @zh 返回定义此四元数的坐标系 X 轴向量
	 */
	static toAxisX(out: IVec3Like, q: IQuatLike): IVec3Like;
	/**
	 * @en This returns the Y-axis vector of the quaternion
	 * @zh 返回定义此四元数的坐标系 Y 轴向量
	 */
	static toAxisY(out: IVec3Like, q: IQuatLike): IVec3Like;
	/**
	 * @en This returns the Z-axis vector of the quaternion
	 * @zh 返回定义此四元数的坐标系 Z 轴向量
	 */
	static toAxisZ(out: IVec3Like, q: IQuatLike): IVec3Like;
	/**
	 * @en Converts the quaternion to angles, result angle x, y in the range of [-180, 180], z in the range of [-90, 90] interval,
	 * the rotation order is YZX, first rotate around Y, then around Z, and finally around X
	 * @zh 根据四元数计算欧拉角，返回角度 x, y 在 [-180, 180] 区间内, z 默认在 [-90, 90] 区间内，旋转顺序为 YZX，即先绕Y旋转，再绕Z，最后绕X旋转。
	 * @param outerZ change z value range to [-180, -90] U [90, 180]
	 */
	static toEuler(out: IVec3Like, q: IQuatLike, outerZ?: boolean): IVec3Like;
	/**
	 * @en Converts the quaternion to euler angles, result angle y, z in the range of [-180, 180], x in the range of [-90, 90],
	 * the rotation order is YXZ, first rotate around Y, then around X, and finally around Z.
	 * @zh 根据四元数计算欧拉角，返回角度 yz 在 [-180, 180], x 在 [-90, 90]，旋转顺序为 YXZ，即先绕Y旋转，再绕X，最后绕Z旋转。
	 */
	static toEulerInYXZOrder(out: Vec3, q: IQuatLike): void;
	/**
	 * @en Converts quaternion to an array
	 * @zh 四元数转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, q: IQuatLike, ofs?: number): Out;
	/**
	 * @en Array to a quaternion
	 * @zh 数组转四元数
	 * @param ofs Array Start Offset
	 */
	static fromArray(out: IQuatLike, arr: Array<number>, ofs?: number): IQuatLike;
	/**
	 * @en Check whether two quaternions are equal
	 * @zh 四元数等价判断
	 */
	static strictEquals(a: IQuatLike, b: IQuatLike): boolean;
	/**
	 * @en Check whether two quaternions are approximately equal
	 * @zh 排除浮点数误差的四元数近似等价判断
	 */
	static equals(a: IQuatLike, b: IQuatLike, epsilon?: number): boolean;
	/**
	 * @en Gets the angular distance between two unit quaternions
	 * @zh 获取两个单位四元数的夹角
	 * @param a The first unit quaternion
	 * @param b The second unit quaternion
	 * @returns Angle between the two quaternions in radians
	 */
	static angle(a: IQuatLike, b: IQuatLike): number;
	/**
	 * @en Rotate a `from` unit quaternion towards `to` unit quaternion
	 * @zh 将一个起始单位四元数旋转到一个目标单位四元数
	 * @param from The first unit quaternion
	 * @param to The second unit quaternion
	 * @param maxStep The maximum angle of rotation in degrees
	 * @returns new unit quaternion generated during rotation
	 */
	static rotateTowards(out: IQuatLike, from: IQuatLike, to: IQuatLike, maxStep: number): IQuatLike;
	/**
	 * @en x component.
	 * @zh x 分量。
	 */
	x: number;
	/**
	 * @en y component.
	 * @zh y 分量。
	 */
	y: number;
	/**
	 * @en z component.
	 * @zh z 分量。
	 */
	z: number;
	/**
	 * @en w component.
	 * @zh w 分量。
	 */
	w: number;
	constructor(other: Quat);
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @en clone the current Quat
	 * @zh 克隆当前四元数。
	 */
	clone(): Quat;
	/**
	 * @en Set values with another quaternion
	 * @zh 设置当前四元数使其与指定四元数相等。
	 * @param other Specified quaternion
	 * @returns `this`
	 */
	set(other: Quat): Quat;
	/**
	 * @en Set the value of each component of the current quaternion
	 * @zh 设置当前四元数指定元素值。
	 * @returns `this`
	 */
	set(x?: number, y?: number, z?: number, w?: number): Quat;
	/**
	 * @en Check whether the quaternion approximately equals another one
	 * @zh 判断当前四元数是否在误差范围内与指定向量相等。
	 * @param other Comparative quaternion
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @returns Returns `true' when the components of the two quaternions are equal within the specified error range; otherwise, returns `false'.
	 */
	equals(other: Quat, epsilon?: number): boolean;
	/**
	 * @en Check whether the current quaternion strictly equals other quaternion
	 * @zh 判断当前四元数是否与指定四元数相等。
	 * @param other Comparative quaternion
	 * @returns Returns `true' when the components of the two quaternions are equal within the specified error range; otherwise, returns `false'.
	 */
	strictEquals(other: Quat): boolean;
	/**
	 * @en Convert quaternion to Euler angles
	 * @zh 将当前四元数转化为欧拉角（x-y-z）并赋值给输出向量。
	 * @param out the output vector
	 */
	getEulerAngles(out: Vec3): IVec3Like;
	/**
	 * @en Calculate the linear interpolation result between this quaternion and another one with given ratio
	 * @zh 根据指定的插值比率，从当前四元数到目标四元数之间做线性插值。
	 * @param to The target quaternion
	 * @param ratio The interpolation coefficient. The range is [0,1].
	 */
	lerp(to: Quat, ratio: number): Quat;
	/**
	 * @en Calculates the spherical interpolation result between this quaternion and another one with the given ratio
	 * @zh 根据指定的插值比率，从当前四元数到目标四元数之间做球面插值。
	 * @param to The target quaternion
	 * @param ratio The interpolation coefficient. The range is [0,1].
	 */
	slerp(to: Quat, ratio: number): Quat;
	/**
	 * @en Calculates the length of the quaternion
	 * @zh 求四元数长度
	 */
	length(): number;
	/**
	 * @en Calculates the squared length of the quaternion
	 * @zh 求四元数长度平方
	 */
	lengthSqr(): number;
}
export declare function quat(other: Quat): Quat;
export declare function quat(x?: number, y?: number, z?: number, w?: number): Quat;
/**
 * @engineInternal
 */
export declare const preTransforms: readonly (readonly number[])[];
/**
 * @en Mathematical 4x4 matrix.
 * @zh 表示四维（4x4）矩阵。
 */
export declare class Mat4 {
	static IDENTITY: Readonly<Mat4>;
	/**
	 * @en Clone a matrix and save the results to out matrix
	 * @zh 获得指定矩阵的拷贝
	 */
	static clone(a: IMat4Like): Mat4;
	/**
	 * @en Copy a matrix into the out matrix
	 * @zh 复制目标矩阵
	 */
	static copy<Out extends IMat4Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets a matrix with the given values and save the results to out matrix
	 * @zh 设置矩阵值
	 *
	 * @param out The receive matrix
	 * @param m00 Component in column 0, row 0 position (index 0)
	 * @param m01 Component in column 0, row 1 position (index 1)
	 * @param m02 Component in column 0, row 2 position (index 2)
	 * @param m03 Component in column 0, row 3 position (index 3)
	 * @param m10 Component in column 1, row 0 position (index 4)
	 * @param m11 Component in column 1, row 1 position (index 5)
	 * @param m12 Component in column 1, row 2 position (index 6)
	 * @param m13 Component in column 1, row 3 position (index 7)
	 * @param m20 Component in column 2, row 0 position (index 8)
	 * @param m21 Component in column 2, row 1 position (index 9)
	 * @param m22 Component in column 2, row 2 position (index 10)
	 * @param m23 Component in column 2, row 3 position (index 11)
	 * @param m30 Component in column 3, row 0 position (index 12)
	 * @param m31 Component in column 3, row 1 position (index 13)
	 * @param m32 Component in column 3, row 2 position (index 14)
	 * @param m33 Component in column 3, row 3 position (index 15)
	 * @returns The receive matrix
	 */
	static set<Out extends IMat4Like>(out: Out, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Out;
	/**
	 * @en return an identity matrix.
	 * @zh 将目标赋值为单位矩阵
	 */
	static identity<Out extends IMat4Like>(out: Out): Out;
	/**
	 * @en Transposes a matrix and save the results to out matrix
	 * @zh 转置矩阵
	 */
	static transpose<Out extends IMat4Like>(out: Out, a: Out): Out;
	/**
	 * @en Inverts a matrix. When matrix is not invertible the matrix will be set to zeros.
	 * @zh 矩阵求逆，注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
	 */
	static invert<Out extends IMat4Like>(out: Out, a: Out): Out;
	/**
	 * @en Calculates the determinant of a matrix
	 * @zh 矩阵行列式
	 */
	static determinant<InType extends IMat4Like>(a: InType): number;
	/**
	 * @en Multiply two matrices and save the results to out matrix, (out = a * b)
	 * @zh 矩阵乘法 (out = a * b)
	 *
	 * @param out The out matrix
	 * @param a The first operand
	 * @param b The second operand
	 * @returns out matrix
	 */
	static multiply<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Translate a matrix with the given vector and save results to the out matrix, the translate is applied before the matrix, i.e. (out = a * T)
	 * @zh 在给定矩阵变换基础上加入平移变换，并将结果保存到 out 矩阵中，平移变换将应用在矩阵变换之前，即 (out = a * T)
	 *
	 * @param out The out matrix
	 * @param a The matrix to translate
	 * @param v The vector to translate with
	 */
	static transform<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
	/**
	 * @en Transform a matrix with the given translation vector and save results to the out matrix,
	 * the translate is applied after the transformation, i.e. (out = T * a)
	 * @zh 在给定矩阵变换基础上加入新位移变换，平移变换在变换之后应用，即 (out = T * a)
	 *
	 * @param out The out matrix
	 * @param a The matrix to translate
	 * @param v The vector to translate with
	 * @deprecated Since 3.8.0, please use [[transform]] instead
	 */
	static translate<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
	/**
	 * @en Multiply a matrix with a scale matrix given by a scale vector and save the results into the out matrix,
	 * the scale is applied before the matrix, i.e. (out = a * S)
	 * @zh 在给定矩阵变换基础上加入新缩放变换，并将结果保存到 out 矩阵中，缩放变换将应用在矩阵变换之前，即 (out = a * S)
	 */
	static scale<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
	/**
	 * @en Rotates the transform by the given angle and save the results into the out matrix, the rotate is applied before
	 * the matrix, i.e. (out = a * R)
	 * @zh 在给定矩阵变换基础上加入新旋转变换, 并将结果保存到 out 矩阵中，旋转变换将应用在矩阵变换之前，即 (out = a * R)
	 * @param rad Angle of rotation (in radians)
	 * @param axis axis of rotation
	 */
	static rotate<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, rad: number, axis: VecLike): Out | null;
	/**
	 * @en Transform a matrix with a given angle around X axis and save the results to the out matrix, the rotate is applied
	 * before the matrix, i.e. (out = a * R)
	 * @zh 在给定矩阵变换基础上加入绕 X 轴的旋转变换, 并将结果保存到 out 矩阵中，旋转变换将应用在矩阵变换之前，即 (out = a * R)
	 * @param rad Angle of rotation (in radians)
	 */
	static rotateX<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Transform a matrix with a given angle around Y axis and save the results to the out matrix
	 * @zh 在给定矩阵变换基础上加入绕 Y 轴的旋转变换
	 * @param rad Angle of rotation (in radians)
	 */
	static rotateY<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Transform a matrix with a given angle around Z axis and save the results to the out matrix
	 * @zh 在给定矩阵变换基础上加入绕 Z 轴的旋转变换
	 * @param rad Angle of rotation (in radians)
	 */
	static rotateZ<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
	/**
	 * @en Sets the out matrix with a translation vector
	 * @zh 计算位移矩阵
	 */
	static fromTranslation<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, v: VecLike): Out;
	/**
	 * @en Sets the out matrix with a scale vector
	 * @zh 计算缩放矩阵
	 */
	static fromScaling<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, v: VecLike): Out;
	/**
	 * @en Sets the out matrix with rotation angle
	 * @zh 计算旋转矩阵
	 */
	static fromRotation<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, rad: number, axis: VecLike): Out | null;
	/**
	 * @en Calculates the matrix representing a rotation around the X axis
	 * @zh 计算绕 X 轴的旋转矩阵
	 */
	static fromXRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
	/**
	 * @en Calculates the matrix representing a rotation around the Y axis
	 * @zh 计算绕 Y 轴的旋转矩阵
	 */
	static fromYRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
	/**
	 * @en Calculates the matrix representing a rotation around the Z axis
	 * @zh 计算绕 Z 轴的旋转矩阵
	 */
	static fromZRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
	/**
	 * @en Calculates the transform representing the combination of a rotation and a translation, and stores the result in out.
	 * The order is rotation then translation.
	 * @zh 根据旋转和位移信息计算矩阵
	 */
	static fromRT<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike): Out;
	/**
	 * @en Extracts the translation from the matrix, assuming it's composed in order of scale, rotation, translation
	 * @zh 提取矩阵的位移信息, 默认矩阵中的变换以 S->R->T 的顺序应用
	 */
	static getTranslation<InType extends IMat4Like, VecLike extends IVec3Like>(out: VecLike, mat: InType): VecLike;
	/**
	 * @en Extracts the scale vector from the matrix, assuming it's composed in order of scale, rotation, translation
	 * @zh 提取矩阵的缩放信息, 默认矩阵中的变换以 S->R->T 的顺序应用
	 */
	static getScaling<InType extends IMat4Like, VecLike extends IVec3Like>(out: VecLike, mat: InType): VecLike;
	/**
	 * @en Extracts the rotation from the matrix, assuming it's composed in order of scale, rotation, translation
	 * @zh 提取矩阵的旋转信息, 默认输入矩阵不含有缩放信息，如考虑缩放应使用 `toRTS` 函数。
	 */
	static getRotation<InType extends IMat4Like>(out: Quat, mat: InType): Quat;
	/**
	 * @en Extracts the scale, rotation and translation from the matrix, assuming it's composed in order of scale, rotation, translation
	 * @zh 提取旋转、位移、缩放信息， 默认矩阵中的变换以 S->R->T 的顺序应用
	 *
	 * @param m The input transform matrix
	 * @param q The corresponding rotation quat
	 * @param v The corresponding translate vector
	 * @param s The corresponding scaling vector
	 *
	 * @deprecated Since 3.8.0, please use toSRT instead
	 */
	static toRTS<InType extends IMat4Like, VecLike extends IVec3Like>(m: InType, q: Quat | null, v: VecLike | null, s: VecLike | null): void;
	/**
	 * @en Extracts the scale, rotation and translation from the matrix, assuming it's composed in order of scale, rotation, translation
	 * @zh 提取旋转、位移、缩放信息， 默认矩阵中的变换以 S->R->T 的顺序应用
	 *
	 * @param m The input transform matrix
	 * @param q The corresponding rotation quat
	 * @param v The corresponding translate vector
	 * @param s The corresponding scaling vector
	 */
	static toSRT<InType extends IMat4Like, VecLike extends IVec3Like>(m: InType, q: Quat | null, v: VecLike | null, s: VecLike | null): void;
	/**
	 * @en Convert Matrix to euler angle, resulting angle y, z in the range of [-PI, PI],
	 *  x in the range of [-PI/2, PI/2], the rotation order is YXZ.
	 * @zh 将矩阵转换为欧拉角，结果角度 y, z 在 [-PI, PI] 范围内，x 在 [-PI/2, PI/2] 区间内，旋转顺序为 YXZ.
	 */
	static toEuler<InType extends IMat4Like, VecLike extends IVec3Like>(m: InType, v: VecLike): boolean;
	/**
	 * @en Compose a matrix from scale, rotation and translation, applied in order.
	 * @zh 根据旋转、位移、缩放信息计算矩阵，以 S->R->T 的顺序应用
	 * @deprecated Since 3.8.0, please use [[fromSRT]] instead.
	 */
	static fromRTS<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike): Out;
	/**
	 * @en Compose a matrix from scale, rotation and translation, applied in order.
	 * @zh 根据旋转、位移、缩放信息计算矩阵，以 S->R->T 的顺序应用
	 * @param out The receiving matrix
	 * @param q Rotation quaternion
	 * @param v Translation vector
	 * @param s Scaling vector
	 * @returns The receiving matrix
	 */
	static fromSRT<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike): Out;
	/**
	 * @en Compose a matrix from scale, rotation and translation, applied in order, from a given origin
	 * @zh 根据指定的旋转、位移、缩放及变换中心信息计算矩阵，以 S->R->T 的顺序应用
	 * @param q Rotation quaternion
	 * @param v Translation vector
	 * @param s Scaling vector
	 * @param o transformation Center
	 * @deprecated Please use [[fromSRTOrigin]] instead.
	 */
	static fromRTSOrigin<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike, o: VecLike): Out;
	/**
	 * @en Compose a matrix from scale, rotation and translation, applied in order, from a given origin
	 * @zh 根据指定的旋转、位移、缩放及变换中心信息计算矩阵，以 O^{-1}->S->R->O->T 的顺序应用
	 * @param out The receiving matrix
	 * @param q Rotation quaternion
	 * @param v Translation vector
	 * @param s Scaling vector
	 * @param o transformation Center
	 * @returns The receiving matrix
	 */
	static fromSRTOrigin<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike, o: VecLike): Out;
	/**
	 * @en Sets the out matrix with the given quaternion
	 * @zh 根据指定的旋转信息计算矩阵
	 */
	static fromQuat<Out extends IMat4Like>(out: Out, q: Quat): Out;
	/**
	 * @en Calculates the matrix representing the given frustum
	 * @zh 根据指定的视锥体信息计算矩阵
	 * @param out The receiving matrix.
	 * @param left The X coordinate of the left side of the near projection plane in view space.
	 * @param right The X coordinate of the right side of the near projection plane in view space.
	 * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
	 * @param top The Y coordinate of the top side of the near projection plane in view space.
	 * @param near Z distance to the near plane from the origin in view space.
	 * @param far Z distance to the far plane from the origin in view space.
	 *
	 * @return The receiving matrix.
	 */
	static frustum<Out extends IMat4Like>(out: Out, left: number, right: number, bottom: number, top: number, near: number, far: number): Out;
	/**
	 * @en Calculates perspective projection matrix
	 * @zh 计算透视投影矩阵
	 * @param out The receiving matrix.
	 * @param fovy Vertical field-of-view in degrees.
	 * @param aspect Aspect ratio
	 * @param near Near depth clipping plane value.
	 * @param far Far depth clipping plane value.
	 * @param isFOVY Whether the fovy is based on the vertical field-of-view.
	 * @param minClipZ The minimum value of the near clipping plane, e.g. -1 for OpenGL, 0 for Vulkan and Metal.
	 * @param projectionSignY The sign of the Y axis of the projection matrix, which is used to flip the Y axis.
	 * @param orientation The orientation of the projection matrix, which is used to rotate the projection matrix.
	 *
	 * @return The receiving matrix.
	 */
	static perspective<Out extends IMat4Like>(out: Out, fov: number, aspect: number, near: number, far: number, isFOVY?: boolean, minClipZ?: number, projectionSignY?: number, orientation?: number): Out;
	/**
	 * @en Calculates orthogonal projection matrix
	 * @zh 计算正交投影矩阵
	 * @param out The receiving matrix.
	 * @param left Left-side x-coordinate.
	 * @param right Right-side x-coordinate.
	 * @param bottom Bottom y-coordinate.
	 * @param top Top y-coordinate.
	 * @param near Near depth clipping plane value.
	 * @param far Far depth clipping plane value.
	 * @param minClipZ The minimum value of the near clipping plane, e.g. -1 for OpenGL, 0 for Vulkan and Metal.
	 * @param projectionSignY The sign of the Y axis of the projection matrix, which is used to flip the Y axis.
	 * @param orientation The orientation of the projection matrix, which is used to rotate the projection matrix.
	 *
	 * @return The receiving matrix.
	 */
	static ortho<Out extends IMat4Like>(out: Out, left: number, right: number, bottom: number, top: number, near: number, far: number, minClipZ?: number, projectionSignY?: number, orientation?: number): Out;
	/**
	 * @en
	 * Calculates the matrix with the view point information, given by eye position, target center and the up vector.
	 * Note that center to eye vector can't be zero or parallel to the up vector
	 * @zh
	 * 计算视图矩阵，给定眼睛位置、目标中心和上向量。注意，中心到眼睛向量不能为零或与上向量平行。
	 * @out The receiving matrix.
	 * @param eye The source point.
	 * @param center The target point.
	 * @param up The vector describing the up direction.
	 * @return The receiving matrix.
	 */
	static lookAt<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, eye: VecLike, center: VecLike, up: VecLike): Out;
	/**
	 * @en Calculates the inverse transpose of a matrix and save the results to out matrix
	 * @zh 计算逆转置矩阵
	 *
	 * @deprecated This function is too complicated, and should be split into several functions.
	 */
	static inverseTranspose<Out extends IMat4Like>(out: Out, a: Out): Out | null;
	/**
	 * @en Transform a matrix object to a flat array
	 * @zh 矩阵转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, m: IMat4Like, ofs?: number): Out;
	/**
	 * @en Generates or sets a matrix with a flat array
	 * @zh 数组转矩阵
	 * @param ofs Array Start Offset
	 */
	static fromArray<Out extends IMat4Like>(out: Out, arr: Array<number>, ofs?: number): Out;
	/**
	 * @en Adds two matrices and save the results to out matrix
	 * @zh 逐元素矩阵加法
	 */
	static add<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Subtracts matrix b from matrix a and save the results to out matrix
	 * @zh 逐元素矩阵减法
	 */
	static subtract<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Multiply each element of a matrix by a scalar number and save the results to out matrix
	 * @zh 矩阵标量乘法
	 */
	static multiplyScalar<Out extends IMat4Like>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Adds two matrices after multiplying each element of the second operand by a scalar number. And save the results to out matrix.
	 * @zh 逐元素矩阵标量乘加: A + B * scale
	 */
	static multiplyScalarAndAdd<Out extends IMat4Like>(out: Out, a: Out, b: Out, scale: number): Out;
	/**
	 * @en Returns whether the specified matrices are equal.
	 * @zh 矩阵等价判断
	 */
	static strictEquals<InType extends IMat4Like>(a: InType, b: InType): boolean;
	/**
	 * @en Returns whether the specified matrices are approximately equal.
	 * @zh 排除浮点数误差的矩阵近似等价判断
	 *
	 * @param a The first matrix to be compared.
	 * @param b The second matrix to be compared.
	 * @param epsilon The tolerance value.
	 * @return
	 */
	static equals<InType extends IMat4Like>(a: InType, b: InType, epsilon?: number): boolean;
	/**
	 * matrix layout
	 * |m00  m04  m08 m12|
	 * |m01  m05  m09 m13|
	 * |m02  m06  m10 m14|
	 * |m03  m07  m11 m15|
	 */
	/**
	 * @en Value at column 0 row 0 of the matrix.
	 * @zh 矩阵第 0 列第 0 行的元素。
	 */
	m00: number;
	/**
	 * @en Value at column 0 row 1 of the matrix.
	 * @zh 矩阵第 0 列第 1 行的元素。
	 */
	m01: number;
	/**
	 * @en Value at column 0 row 2 of the matrix.
	 * @zh 矩阵第 0 列第 2 行的元素。
	 */
	m02: number;
	/**
	 * @en Value at column 0 row 3 of the matrix.
	 * @zh 矩阵第 0 列第 3 行的元素。
	 */
	m03: number;
	/**
	 * @en Value at column 1 row 0 of the matrix.
	 * @zh 矩阵第 1 列第 0 行的元素。
	 */
	m04: number;
	/**
	 * @en Value at column 1 row 1 of the matrix.
	 * @zh 矩阵第 1 列第 1 行的元素。
	 */
	m05: number;
	/**
	 * @en Value at column 1 row 2 of the matrix.
	 * @zh 矩阵第 1 列第 2 行的元素。
	 */
	m06: number;
	/**
	 * @en Value at column 1 row 3 of the matrix.
	 * @zh 矩阵第 1 列第 3 行的元素。
	 */
	m07: number;
	/**
	 * @en Value at column 2 row 0 of the matrix.
	 * @zh 矩阵第 2 列第 0 行的元素。
	 */
	m08: number;
	/**
	 * @en Value at column 2 row 1 of the matrix.
	 * @zh 矩阵第 2 列第 1 行的元素。
	 */
	m09: number;
	/**
	 * @en Value at column 2 row 2 of the matrix.
	 * @zh 矩阵第 2 列第 2 行的元素。
	 */
	m10: number;
	/**
	 * @en Value at column 2 row 3 of the matrix.
	 * @zh 矩阵第 2 列第 3 行的元素。
	 */
	m11: number;
	/**
	 * @en Value at column 3 row 0 of the matrix.
	 * @zh 矩阵第 3 列第 0 行的元素。
	 */
	m12: number;
	/**
	 * @en Value at column 3 row 1 of the matrix.
	 * @zh 矩阵第 3 列第 1 行的元素。
	 */
	m13: number;
	/**
	 * @en Value at column 3 row 2 of the matrix.
	 * @zh 矩阵第 3 列第 2 行的元素。
	 */
	m14: number;
	/**
	 * @en Value at column 3 row 3 of the matrix.
	 * @zh 矩阵第 3 列第 3 行的元素。
	 */
	m15: number;
	constructor(other: Mat4);
	constructor(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number, m09?: number, m10?: number, m11?: number, m12?: number, m13?: number, m14?: number, m15?: number);
	/**
	 * @en Clone a new matrix from the current matrix.
	 * @zh 克隆当前矩阵。
	 */
	clone(): Mat4;
	/**
	 * @en Sets the matrix with another one's value.
	 * @zh 设置当前矩阵使其与指定矩阵相等。
	 * @param other Specified matrix.
	 * @return this
	 */
	set(other: Mat4): Mat4;
	/**
	 * @en Set the matrix with values of all elements
	 * @zh 设置当前矩阵指定元素值。
	 *
	 * @return this
	 */
	set(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number, m09?: number, m10?: number, m11?: number, m12?: number, m13?: number, m14?: number, m15?: number): Mat4;
	/**
	 * @en Returns whether the specified matrices are approximately equal.
	 * @zh 判断当前矩阵是否在误差范围内与指定矩阵相等。
	 * @param other Comparative matrix
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
	 */
	equals(other: Mat4, epsilon?: number): boolean;
	/**
	 * @en Returns whether the specified matrices are equal.
	 * @zh 判断当前矩阵是否与指定矩阵相等。
	 * @param other Comparative matrix
	 * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
	 */
	strictEquals(other: Mat4): boolean;
	/**
	 * @en Returns a string representation of a matrix.
	 * @zh 返回当前矩阵的字符串表示。
	 * @return 当前矩阵的字符串表示。
	 */
	toString(): string;
	/**
	 * @en set the current matrix to an identity matrix.
	 * @zh 将当前矩阵设为单位矩阵。
	 * @return `this`
	 */
	identity(): Mat4;
	/**
	 * @en set the current matrix to an zero matrix.
	 * @zh 将当前矩阵设为 0矩阵。
	 * @return `this`
	 */
	zero(): Mat4;
	/**
	 * @en Transposes the current matrix.
	 * @zh 计算当前矩阵的转置矩阵。
	 */
	transpose(): Mat4;
	/**
	 * @en Inverts the current matrix. When matrix is not invertible the matrix will be set to zeros.
	 * @zh 计算当前矩阵的逆矩阵。注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
	 */
	invert(): Mat4;
	/**
	 * @en Calculates the determinant of the current matrix.
	 * @zh 计算当前矩阵的行列式。
	 * @return 当前矩阵的行列式。
	 */
	determinant(): number;
	/**
	 * @en Adds the current matrix and another matrix to the current matrix.
	 * @zh 矩阵加法。将当前矩阵与指定矩阵的相加，结果返回给当前矩阵。
	 * @param mat the second operand
	 */
	add(mat: Mat4): Mat4;
	/**
	 * @en Subtracts another matrix from the current matrix.
	 * @zh 计算矩阵减法。将当前矩阵减去指定矩阵的结果赋值给当前矩阵。
	 * @param mat the second operand
	 */
	subtract(mat: Mat4): Mat4;
	/**
	 * @en Multiply the current matrix with another matrix.
	 * @zh 矩阵乘法。将当前矩阵左乘指定矩阵的结果赋值给当前矩阵。
	 * @param mat the second operand
	 */
	multiply(mat: Mat4): Mat4;
	/**
	 * @en Multiply each element of the current matrix by a scalar number.
	 * @zh 矩阵数乘。将当前矩阵与指定标量的数乘结果赋值给当前矩阵。
	 * @param scalar amount to scale the matrix's elements by
	 */
	multiplyScalar(scalar: number): Mat4;
	/**
	 * @en Translate the current matrix by the given vector
	 * @zh 将当前矩阵左乘位移矩阵的结果赋值给当前矩阵，位移矩阵由各个轴的位移给出。
	 * @param vec vector to translate by
	 *
	 * @deprecated since v3.0, please use [[transform]] instead
	 */
	translate(vec: Vec3): Mat4;
	/**
	 * @en Translate the current matrix by the given vector
	 * @zh 将当前矩阵左乘位移矩阵的结果赋值给当前矩阵，位移矩阵由各个轴的位移给出。
	 * @param vec vector to translate by
	 */
	transform(vec: Vec3): Mat4;
	/**
	 * @en Multiply the current matrix with a scale vector.
	 * @zh 将当前矩阵左乘缩放矩阵的结果赋值给当前矩阵，缩放矩阵由各个轴的缩放给出。
	 * @param vec vector to scale by
	 */
	scale(vec: Vec3): Mat4;
	/**
	 * @en Rotates the current matrix by the given angle around the given axis
	 * @zh 将当前矩阵左乘旋转矩阵的结果赋值给当前矩阵，旋转矩阵由旋转轴和旋转角度给出。
	 * @param rad Angle of rotation (in radians)
	 * @param axis Axis of rotation
	 */
	rotate(rad: number, axis: Vec3): Mat4 | null;
	/**
	 * @en Returns the translation vector component of a transformation matrix.
	 * @zh 从当前矩阵中计算出位移变换的部分，并以各个轴上位移的形式赋值给输出向量。
	 * @param out Vector to receive translation component.
	 */
	getTranslation(out: Vec3): Vec3;
	/**
	 * @en Returns the scale factor component of a transformation matrix
	 * @zh 从当前矩阵中计算出缩放变换的部分，并以各个轴上缩放的形式赋值给输出向量。
	 * @param out Vector to receive scale component
	 */
	getScale(out: Vec3): Vec3;
	/**
	 * @en Returns the rotation factor component of a transformation matrix
	 * @zh 从当前矩阵中计算出旋转变换的部分，并以四元数的形式赋值给输出四元数。
	 * @param out Vector to receive rotation component
	 */
	getRotation(out: Quat): Quat;
	/**
	 * @en Resets the matrix values by the given rotation quaternion, translation vector and scale vector
	 * @zh 重置当前矩阵的值，使其表示指定的旋转、缩放、位移依次组合的变换。
	 * @param q Rotation quaternion
	 * @param v Translation vector
	 * @param s Scaling vector
	 * @return `this`
	 *
	 * @deprecated Since 3.8.0, please use [[fromSRT]] instead
	 */
	fromRTS(q: Quat, v: Vec3, s: Vec3): Mat4;
	/**
	 * @en Resets the matrix values by the given rotation quaternion, translation vector and scale vector
	 * @zh 重置当前矩阵的值，使其表示指定的旋转、缩放、位移依次组合的变换。
	 * @param q Rotation quaternion
	 * @param v Translation vector
	 * @param s Scaling vector
	 * @return `this`
	 */
	fromSRT(q: Quat, v: Vec3, s: Vec3): Mat4;
	/**
	 * @en Resets the current matrix from the given quaternion.
	 * @zh 重置当前矩阵的值，使其表示指定四元数表示的旋转变换。
	 * @param q Rotation quaternion
	 * @return `this`
	 */
	fromQuat(q: Quat): Mat4;
}
export declare function mat4(other: Mat4): Mat4;
export declare function mat4(m00?: number, m01?: number, m02?: number, m03?: number, m10?: number, m11?: number, m12?: number, m13?: number, m20?: number, m21?: number, m22?: number, m23?: number, m30?: number, m31?: number, m32?: number, m33?: number): Mat4;
/**
 * @en Representation of 2D vectors and points.
 * @zh 二维向量。
 */
export declare class Vec2 {
	static ZERO: Readonly<Vec2>;
	static ONE: Readonly<Vec2>;
	static NEG_ONE: Readonly<Vec2>;
	static UNIT_X: Readonly<Vec2>;
	static UNIT_Y: Readonly<Vec2>;
	/**
	 * @en Obtains a clone of the given vector object
	 * @zh 获得指定向量的拷贝
	 */
	static clone<Out extends IVec2Like>(a: Out): Vec2;
	/**
	 * @en Copy the target vector and save the results to out vector object
	 * @zh 复制目标向量
	 */
	static copy<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets the out vector with the given x and y values
	 * @zh 设置向量值
	 */
	static set<Out extends IVec2Like>(out: Out, x: number, y: number): Out;
	/**
	 * @en Element-wise vector addition and save the results to out vector object
	 * @zh 逐元素向量加法
	 */
	static add<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Element-wise vector subtraction and save the results to out vector object
	 * @zh 逐元素向量减法
	 */
	static subtract<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Element-wise vector multiplication and save the results to out vector object
	 * @zh 逐元素向量乘法
	 */
	static multiply<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Element-wise vector division and save the results to out vector object
	 * @zh 逐元素向量除法
	 */
	static divide<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Rounds up by elements of the vector and save the results to out vector object
	 * @zh 逐元素向量向上取整
	 */
	static ceil<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Element-wise rounds down of the current vector and save the results to the out vector
	 * @zh 逐元素向量向下取整
	 */
	static floor<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Calculates element-wise minimum values and save to the out vector
	 * @zh 逐元素向量最小值
	 */
	static min<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Calculates element-wise maximum values and save to the out vector
	 * @zh 逐元素向量最大值
	 */
	static max<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Calculates element-wise round results and save to the out vector
	 * @zh 逐元素向量四舍五入取整
	 */
	static round<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Vector scalar multiplication and save the results to out vector object
	 * @zh 向量标量乘法
	 */
	static multiplyScalar<Out extends IVec2Like>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Element-wise multiplication and addition with the equation: a + b * scale
	 * @zh 逐元素向量乘加: A + B * scale
	 */
	static scaleAndAdd<Out extends IVec2Like>(out: Out, a: Out, b: Out, scale: number): Out;
	/**
	 * @en Calculates the euclidean distance of two vectors
	 * @zh 求两向量的欧氏距离
	 */
	static distance<Out extends IVec2Like>(a: Out, b: Out): number;
	/**
	 * @en Calculates the squared euclidean distance of two vectors
	 * @zh 求两向量的欧氏距离平方
	 */
	static squaredDistance<Out extends IVec2Like>(a: Out, b: Out): number;
	/**
	 * @en Calculates the length of the vector
	 * @zh 求向量长度
	 */
	static len<Out extends IVec2Like>(a: Out): number;
	/**
	 * @en Calculates the squared length of the vector
	 * @zh 求向量长度平方
	 */
	static lengthSqr<Out extends IVec2Like>(a: Out): number;
	/**
	 * @en Sets each element to its negative value
	 * @zh 逐元素向量取负
	 */
	static negate<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets each element to its inverse value, zero value will become Infinity
	 * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
	 */
	static inverse<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets each element to its inverse value, zero value will remain zero
	 * @zh 逐元素向量取倒数，接近 0 时返回 0
	 */
	static inverseSafe<Out extends IVec2Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets the normalized vector to the out vector, returns a zero vector if input is a zero vector.
	 * @zh 归一化向量，输入零向量将会返回零向量。
	 */
	static normalize<Out extends IVec2Like, Vec2Like extends IVec2Like>(out: Out, a: Vec2Like): Out;
	/**
	 * @en Calculates the dot product of the vector
	 * @zh 向量点积（数量积）
	 */
	static dot<Out extends IVec2Like>(a: Out, b: Out): number;
	/**
	 * @en Calculates the cross product of the vector
	 * @zh 向量叉积（向量积），注意二维向量的叉积为与 Z 轴平行的三维向量
	 * @override (a:Vec2, b:Vec2) => number
	 * @override [deprecated] (out:Vec3, a:Vec2, b:Vec2) => Vec3
	 */
	static cross(a: IVec2Like, b: IVec2Like): number;
	/**
	 * @deprecated Consider use another overrides please.
	 */
	static cross<Out extends IVec2Like>(out: Vec3, a: Out, b: Out): Vec3;
	/**
	 * @en Calculates the linear interpolation between two vectors with a given ratio: A + t * (B - A)
	 * @zh 逐元素向量线性插值： A + t * (B - A)
	 */
	static lerp<Out extends IVec2Like>(out: Out, a: Out, b: Out, t: number): Out;
	/**
	 * @en Generates a uniformly distributed random vector points from center to the surface of the unit sphere
	 * @zh 生成一个在单位圆上均匀分布的随机向量
	 * @param scale vector length
	 */
	static random<Out extends IVec2Like>(out: Out, scale?: number): Out;
	/**
	 * @en Vector and third order matrix multiplication, will complete the vector with a third value as one
	 * @zh 向量与三维矩阵乘法，默认向量第三位为 1。
	 */
	static transformMat3<Out extends IVec2Like, MatLike extends IMat3Like>(out: Out, a: Out, m: IMat3Like): Out;
	/**
	 * @en Vector and third order matrix multiplication, will complete the vector with a third and a fourth element as one
	 * @zh 向量与四维矩阵乘法，默认向量第三位为 0，第四位为 1。
	 */
	static transformMat4<Out extends IVec2Like, MatLike extends IMat4Like>(out: Out, a: Out, m: IMat4Like): Out;
	/**
	 * @en Gets the string representation of the given vector
	 * @zh 返回向量的字符串表示
	 */
	static str<Out extends IVec2Like>(a: Out): string;
	/**
	 * @en Converts the given vector to an array
	 * @zh 向量转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, v: IVec2Like, ofs?: number): Out;
	/**
	 * @en Converts the given array to a vector
	 * @zh 数组转向量
	 * @param ofs Array Start Offset
	 */
	static fromArray<Out extends IVec2Like>(out: Out, arr: Array<number>, ofs?: number): Out;
	/**
	 * @en Check the equality of the two given vectors
	 * @zh 向量等价判断
	 */
	static strictEquals<Out extends IVec2Like>(a: Out, b: Out): boolean;
	/**
	 * @en Check whether the two given vectors are approximately equivalent
	 * @zh 排除浮点数误差的向量近似等价判断
	 */
	static equals<Out extends IVec2Like>(a: Out, b: Out, epsilon?: number): boolean;
	/**
	 * @en Calculates the radian angle between two vectors, returns zero if either vector is a zero vector.
	 * @zh 求两向量夹角弧度，任意一个向量是零向量则返回零。
	 */
	static angle<Out extends IVec2Like>(a: Out, b: Out): number;
	/**
	 * @en x component.
	 * @zh x 分量。
	 */
	x: number;
	/**
	 * @en y component.
	 * @zh y 分量。
	 */
	y: number;
	constructor(other: Vec2);
	constructor(x?: number, y?: number);
	/**
	 * @en clone a Vec2 value
	 * @zh 克隆当前向量。
	 */
	clone(): Vec2;
	/**
	 * @en Set the current vector value with the given vector.
	 * @zh 设置当前向量使其与指定向量相等。
	 * @param other Specified vector
	 * @return `this`
	 */
	set(other: Vec2): Vec2;
	/**
	 * @en Set the value of each component of the current vector.
	 * @zh 设置当前向量的具体分量值。
	 * @param x x value
	 * @param y y value
	 * @return `this`
	 */
	set(x?: number, y?: number): Vec2;
	/**
	 * @en Check whether the vector approximately equals another one.
	 * @zh 判断当前向量是否在误差范围内与指定向量相等。
	 * @param other Specified vector
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	equals(other: Vec2, epsilon?: number): boolean;
	/**
	 * @en Check whether the vector approximately equals another one.
	 * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	equals2f(x: number, y: number, epsilon?: number): boolean;
	/**
	 * @en Check whether the current vector strictly equals another Vec2.
	 * @zh 判断当前向量是否与指定向量相等。
	 * @param other specified vector
	 * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	strictEquals(other: Vec2): boolean;
	/**
	 * @en Check whether the current vector strictly equals another Vec2.
	 * @zh 判断当前向量是否与指定分量的向量相等。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	strictEquals2f(x: number, y: number): boolean;
	/**
	 * @en Transform to string with vector information.
	 * @zh 返回当前向量的字符串表示。
	 * @returns The string with vector information
	 */
	toString(): string;
	/**
	 * @en Calculate linear interpolation result between this vector and another one with given ratio.
	 * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
	 * @param to Target vector
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	lerp(to: Vec2, ratio: number): Vec2;
	/**
	 * @en Clamp the vector between minInclusive and maxInclusive.
	 * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
	 * @param minInclusive Minimum value allowed
	 * @param maxInclusive Maximum value allowed
	 * @return `this`
	 */
	clampf(minInclusive: Vec2, maxInclusive: Vec2): Vec2;
	/**
	 * @en Adds the current vector with another one and return this
	 * @zh 向量加法。将当前向量与指定向量的相加
	 * @param other specified vector
	 */
	add(other: Vec2): Vec2;
	/**
	 * @en Adds the current vector with another one and return this
	 * @zh 向量加法。将当前向量与指定分量的向量相加
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 */
	add2f(x: number, y: number): Vec2;
	/**
	 * @en Subtracts one vector from this, and returns this.
	 * @zh 向量减法。将当前向量减去指定向量
	 * @param other specified vector
	 */
	subtract(other: Vec2): Vec2;
	/**
	 * @en Subtracts one vector from this, and returns this.
	 * @zh 向量减法。将当前向量减去指定分量的向量
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 */
	subtract2f(x: number, y: number): Vec2;
	/**
	 * @en Multiplies the current vector with a number, and returns this.
	 * @zh 向量数乘。将当前向量数乘指定标量
	 * @param scalar scalar number
	 */
	multiplyScalar(scalar: number): Vec2;
	/**
	 * @en Multiplies the current vector with another one and return this
	 * @zh 向量乘法。将当前向量乘以与指定向量的结果赋值给当前向量。
	 * @param other specified vector
	 */
	multiply(other: Vec2): Vec2;
	/**
	 * @en Multiplies the current vector with another one and return this
	 * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 */
	multiply2f(x: number, y: number): Vec2;
	/**
	 * @en Element-wisely divides this vector with another one, and return this.
	 * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
	 * @param other specified vector
	 */
	divide(other: Vec2): Vec2;
	/**
	 * @en Element-wisely divides this vector with another one, and return this.
	 * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 */
	divide2f(x: number, y: number): Vec2;
	/**
	 * @en Sets each component of this vector with its negative value
	 * @zh 将当前向量的各个分量取反
	 */
	negative(): Vec2;
	/**
	 * @en Calculates the dot product with another vector
	 * @zh 向量点乘。
	 * @param other specified vector
	 * @return The result of calculates the dot product with another vector
	 */
	dot(other: Vec2): number;
	/**
	 * @en Calculates the cross product with another vector.
	 * @zh 向量叉乘。
	 * @param other specified vector
	 * @return `out`
	 */
	cross(other: Vec2): number;
	/**
	 * @en Returns the length of this vector.
	 * @zh 计算向量的长度（模）。
	 * @return Length of vector
	 */
	length(): number;
	/**
	 * @en Returns the squared length of this vector.
	 * @zh 计算向量长度（模）的平方。
	 * @return the squared length of this vector
	 */
	lengthSqr(): number;
	/**
	 * @en Normalize the current vector.
	 * @zh 将当前向量归一化。
	 */
	normalize(): Vec2;
	/**
	 * @en Calculates radian angle between two vectors, returns zero if either vector is a zero vector.
	 * @zh 获取当前向量和指定向量之间的弧度，任意一个向量是零向量则返回零。
	 * @param other specified vector.
	 * @return The angle between the current vector and the specified vector.
	 */
	angle(other: Vec2): number;
	/**
	 * @en Get angle in radian between this and vector with direction.
	 * @zh 获取当前向量和指定向量之间的有符号弧度。<br/>
	 * 有符号弧度的取值范围为 (-PI, PI]，当前向量可以通过逆时针旋转有符号角度与指定向量同向。<br/>
	 * @param other specified vector
	 * @return The signed angle between the current vector and the specified vector (in radians); if there is a zero vector in the current vector and the specified vector, 0 is returned.
	 */
	signAngle(other: Vec2): number;
	/**
	 * @en Rotates the current vector by an angle in radian value. Counterclockwise is the positive direction.
	 * @zh 将当前向量进行旋转，逆时针为正方向。
	 * @param radians radians of rotation.
	 */
	rotate(radians: number): Vec2;
	/**
	 * @en Projects the current vector on another one
	 * @zh 计算当前向量在指定向量上的投影向量。
	 * @param other specified vector
	 */
	project(other: Vec2): Vec2;
	/**
	 * @en Transforms the vec2 with a mat4. 3rd vector component is implicitly '0', 4th vector component is implicitly '1'
	 * @zh 将当前向量视为 z 分量为 0、w 分量为 1 的四维向量，<br/>
	 * 应用四维矩阵变换到当前矩阵<br/>
	 * @param matrix matrix to transform with
	 */
	transformMat4(matrix: Mat4): Vec2;
}
export declare function v2(other: Vec2): Vec2;
export declare function v2(x?: number, y?: number): Vec2;
/**
 * @en Representation of four-dimensional vectors.
 * @zh 四维向量。
 */
export declare class Vec4 {
	static ZERO: Readonly<Vec4>;
	static ONE: Readonly<Vec4>;
	static NEG_ONE: Readonly<Vec4>;
	static UNIT_X: Readonly<Vec4>;
	static UNIT_Y: Readonly<Vec4>;
	static UNIT_Z: Readonly<Vec4>;
	static UNIT_W: Readonly<Vec4>;
	/**
	 * @en Obtains a clone of the given vector object
	 * @zh 获得指定向量的拷贝
	 */
	static clone<Out extends IVec4Like>(a: Out): Vec4;
	/**
	 * @en Copy the target vector and save the results to out vector object
	 * @zh 复制目标向量
	 */
	static copy<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets the out vector with the given x, y, z and w values
	 * @zh 设置向量值
	 */
	static set<Out extends IVec4Like>(out: Out, x: number, y: number, z: number, w: number): Out;
	/**
	 * @en set value from color
	 * @zh 从颜色值设置向量
	 * @param out
	 * @param color
	 */
	static fromColor<Out extends IVec4Like>(out: Out, color: IColorLike): Out;
	/**
	 * @en The angle between two vectors
	 * @zh 两个向量之间的夹角
	 */
	static angle<Out extends IVec4Like>(a: Out, b: Out): number;
	/**
	 * @en Element-wise vector addition and save the results to out vector object
	 * @zh 逐元素向量加法
	 */
	static add<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Element-wise vector subtraction and save the results to out vector object
	 * @zh 逐元素向量减法
	 */
	static subtract<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Element-wise vector multiplication and save the results to out vector object
	 * @zh 逐元素向量乘法
	 */
	static multiply<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Element-wise vector division and save the results to out vector object
	 * @zh 逐元素向量除法
	 */
	static divide<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Rounds up by elements of the vector and save the results to out vector object
	 * @zh 逐元素向量向上取整
	 */
	static ceil<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Element-wise rounds down of the current vector and save the results to the out vector
	 * @zh 逐元素向量向下取整
	 */
	static floor<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Calculates the minimum values by elements of the vector and save the results to the out vector
	 * @zh 逐元素向量最小值
	 */
	static min<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Calculates the maximum values by elements of the vector and save the results to the out vector
	 * @zh 逐元素向量最大值
	 */
	static max<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Calculates element-wise round results and save to the out vector
	 * @zh 逐元素向量四舍五入取整
	 */
	static round<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Vector scalar multiplication and save the results to out vector object
	 * @zh 向量标量乘法
	 */
	static multiplyScalar<Out extends IVec4Like>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Element-wise multiplication and addition with the equation: a + b * scale
	 * @zh 逐元素向量乘加: A + B * scale
	 */
	static scaleAndAdd<Out extends IVec4Like>(out: Out, a: Out, b: Out, scale: number): Out;
	/**
	 * @en Calculates the euclidean distance of two vectors
	 * @zh 求两向量的欧氏距离
	 */
	static distance<Out extends IVec4Like>(a: Out, b: Out): number;
	/**
	 * @en Calculates the squared euclidean distance of two vectors
	 * @zh 求两向量的欧氏距离平方
	 */
	static squaredDistance<Out extends IVec4Like>(a: Out, b: Out): number;
	/**
	 * @en Calculates the length of the vector
	 * @zh 求向量长度
	 */
	static len<Out extends IVec4Like>(a: Out): number;
	/**
	 * @en Calculates the squared length of the vector
	 * @zh 求向量长度平方
	 */
	static lengthSqr<Out extends IVec4Like>(a: Out): number;
	/**
	 * @en Sets each element to its negative value
	 * @zh 逐元素向量取负
	 */
	static negate<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets each element to its inverse value, zero value will become Infinity
	 * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
	 */
	static inverse<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets each element to its inverse value, zero value will remain zero
	 * @zh 逐元素向量取倒数，接近 0 时返回 0
	 */
	static inverseSafe<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Sets the normalized vector to the out vector, returns a zero vector if input is a zero vector.
	 * @zh 归一化向量，输入零向量将会返回零向量。
	 */
	static normalize<Out extends IVec4Like>(out: Out, a: Out): Out;
	/**
	 * @en Calculates the dot product of the vector
	 * @zh 向量点积（数量积）
	 */
	static dot<Out extends IVec4Like>(a: Out, b: Out): number;
	/**
	 * @en Calculates the linear interpolation between two vectors with a given ratio
	 * @zh 逐元素向量线性插值： A + t * (B - A)
	 */
	static lerp<Out extends IVec4Like>(out: Out, a: Out, b: Out, t: number): Out;
	/**
	 * @en Scales all ell elements of this vector by the specified scalar value
	 * @zh 逐元素向量缩放
	 */
	static scale<Out extends IVec4Like>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Generates a uniformly distributed random vector points from center to the surface of the unit sphere
	 * @zh 生成一个在单位球体上均匀分布的随机向量
	 * @param scale vector length
	 */
	static random<Out extends IVec4Like>(out: Out, scale?: number): Out;
	/**
	 * @en Vector and fourth order matrix multiplication
	 * @zh 向量与四维矩阵乘法
	 */
	static transformMat4<Out extends IVec4Like, MatLike extends IMat4Like>(out: Out, a: Out, m: MatLike): Out;
	/**
	 * @en Transform the vector with the given affine transformation
	 * @zh 向量仿射变换
	 */
	static transformAffine<Out extends IVec4Like, VecLike extends IVec4Like, MatLike extends IMat4Like>(out: Out, v: VecLike, m: MatLike): Out;
	/**
	 * @en Vector quaternion multiplication
	 * @zh 向量四元数乘法
	 */
	static transformQuat<Out extends IVec4Like, QuatLike extends IQuatLike>(out: Out, a: Out, q: QuatLike): Out;
	/**
	 * @en Converts the given vector to an array
	 * @zh 向量转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, v: IVec4Like, ofs?: number): Out;
	/**
	 * @en Converts the given array to a vector
	 * @zh 数组转向量
	 * @param ofs Array Start Offset
	 */
	static fromArray<Out extends IVec4Like>(out: Out, arr: Array<number>, ofs?: number): Out;
	/**
	 * @en Check the equality of the two given vectors
	 * @zh 向量等价判断
	 */
	static strictEquals<Out extends IVec4Like>(a: Out, b: Out): boolean;
	/**
	 * @en Check whether the two given vectors are approximately equivalent
	 * @zh 排除浮点数误差的向量近似等价判断
	 */
	static equals<Out extends IVec4Like>(a: Out, b: Out, epsilon?: number): boolean;
	/**
	 * @en x component.
	 * @zh x 分量。
	 */
	x: number;
	/**
	 * @en y component.
	 * @zh y 分量。
	 */
	y: number;
	/**
	 * @en z component.
	 * @zh z 分量。
	 */
	z: number;
	/**
	 * @en w component.
	 * @zh w 分量。
	 */
	w: number;
	constructor(other: Vec4);
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @en clone the current Vec4 value.
	 * @zh 克隆当前向量。
	 */
	clone(): Vec4;
	/**
	 * @en Set the current vector value with the given vector.
	 * @zh 设置当前向量使其与指定向量相等。
	 * @param other Specified vector
	 * @returns `this`
	 */
	set(other: Vec4): Vec4;
	/**
	 * @en Set the value of each component of the current vector.
	 * @zh 设置当前向量的具体分量值。
	 * @param x x value
	 * @param y y value
	 * @param z z value
	 * @param w w value
	 * @returns `this`
	 */
	set(x?: number, y?: number, z?: number, w?: number): Vec4;
	/**
	 * @en Check whether the vector approximately equals another one.
	 * @zh 判断当前向量是否在误差范围内与指定向量相等。
	 * @param other Specified vector
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	equals(other: Vec4, epsilon?: number): boolean;
	/**
	 * @en Check whether the vector approximately equals another one.
	 * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param w The w value of specified vector
	 * @param epsilon The error allowed. It`s should be a non-negative number.
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	equals4f(x: number, y: number, z: number, w: number, epsilon?: number): boolean;
	/**
	 * @en Check whether the current vector strictly equals another Vec4.
	 * @zh 判断当前向量是否与指定向量相等。
	 * @param other specified vector
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	strictEquals(other: Vec4): boolean;
	/**
	 * @en Check whether the current vector strictly equals another Vec4.
	 * @zh 判断当前向量是否与指定分量的向量相等。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param w The w value of specified vector
	 * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
	 */
	strictEquals4f(x: number, y: number, z: number, w: number): boolean;
	/**
	 * @en Calculate linear interpolation result between this vector and another one with given ratio.
	 * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
	 * @param to Target vector
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	lerp(to: Vec4, ratio: number): Vec4;
	/**
	 * @en Return the information of the vector in string
	 * @zh 返回当前向量的字符串表示。
	 * @returns The string with vector information
	 */
	toString(): string;
	/**
	 * @en Clamp the vector between minInclusive and maxInclusive.
	 * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
	 * @param minInclusive Minimum value allowed
	 * @param maxInclusive Maximum value allowed
	 * @returns `this`
	 */
	clampf(minInclusive: Vec4, maxInclusive: Vec4): Vec4;
	/**
	 * @en Adds the current vector with another one and return this
	 * @zh 向量加法。将当前向量与指定向量的相加
	 * @param other specified vector
	 */
	add(other: Vec4): Vec4;
	/**
	 * @en Adds the current vector with another one and return this
	 * @zh 向量加法。将当前向量与指定分量的向量相加
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param w The w value of specified vector
	 */
	add4f(x: number, y: number, z: number, w: number): Vec4;
	/**
	 * @en Subtracts one vector from this, and returns this.
	 * @zh 向量减法。将当前向量减去指定向量
	 * @param other specified vector
	 */
	subtract(other: Vec4): Vec4;
	/**
	 * @en Subtracts one vector from this, and returns this.
	 * @zh 向量减法。将当前向量减去指定分量的向量
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param w The w value of specified vector
	 */
	subtract4f(x: number, y: number, z: number, w: number): Vec4;
	/**
	 * @en Multiplies the current vector with a number, and returns this.
	 * @zh 向量数乘。将当前向量数乘指定标量
	 * @param scalar scalar number
	 */
	multiplyScalar(scalar: number): Vec4;
	/**
	 * @en Multiplies the current vector with another one and return this
	 * @zh 向量乘法。将当前向量乘以指定向量
	 * @param other specified vector
	 */
	multiply(other: Vec4): Vec4;
	/**
	 * @en Multiplies the current vector with another one and return this
	 * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param w The w value of specified vector
	 */
	multiply4f(x: number, y: number, z: number, w: number): Vec4;
	/**
	 * @en Element-wisely divides this vector with another one, and return this.
	 * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
	 * @param other specified vector
	 */
	divide(other: Vec4): Vec4;
	/**
	 * @en Element-wisely divides this vector with another one, and return this.
	 * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
	 * @param x The x value of specified vector
	 * @param y The y value of specified vector
	 * @param z The z value of specified vector
	 * @param w The w value of specified vector
	 */
	divide4f(x: number, y: number, z: number, w: number): Vec4;
	/**
	 * @en Sets each component of this vector with its negative value
	 * @zh 将当前向量的各个分量取反
	 */
	negative(): Vec4;
	/**
	 * @en Calculates the dot product with another vector
	 * @zh 向量点乘。
	 * @param other specified vector
	 * @returns 当前向量与指定向量点乘的结果。
	 */
	dot(vector: Vec4): number;
	/**
	 * @en Calculates the cross product with another vector.
	 * @zh 向量叉乘。视当前向量和指定向量为三维向量（舍弃 w 分量），将当前向量左叉乘指定向量
	 * @param other specified vector
	 *
	 * @deprecated since v3.8 cross product only defined in 3D space, use [[Vec3.cross]] instead.
	 */
	cross(vector: Vec4): Vec4;
	/**
	 * @en Returns the length of this vector.
	 * @zh 计算向量的长度（模）。
	 * @returns Length of vector
	 */
	length(): number;
	/**
	 * @en Returns the squared length of this vector.
	 * @zh 计算向量长度（模）的平方。
	 * @returns the squared length of this vector
	 */
	lengthSqr(): number;
	/**
	 * @en Normalize the current vector.
	 * @zh 将当前向量归一化
	 */
	normalize(): Vec4;
	/**
	 * @en Scales the current vector by a scalar number.
	 * @zh 向量数乘。
	 */
	scale(scalar: number): Vec4;
	/**
	 * @en Transforms the vec4 with a mat4
	 * @zh 应用四维矩阵变换到当前矩阵
	 * @param matrix matrix to transform with
	 */
	transformMat4(matrix: Mat4): Vec4;
}
export declare function v4(other: Vec4): Vec4;
export declare function v4(x?: number, y?: number, z?: number, w?: number): Vec4;
/**
 * @en Two dimensional size type representing the width and height.
 * @zh 二维尺寸。
 */
export declare class Size {
	static ZERO: Readonly<Size>;
	static ONE: Readonly<Size>;
	/**
	 * @en Calculate the interpolation result between this size and another one with given ratio
	 * @zh 根据指定的插值比率，从当前尺寸到目标尺寸之间做插值。
	 * @param out Output Size.
	 * @param from Original Size.
	 * @param to Target Size.
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 * @returns A vector consisting of linear interpolation of the width and height of the current size to the width and height of the target size at a specified interpolation ratio, respectively.
	 */
	static lerp<Out extends ISizeLike>(out: Out, from: Out, to: Out, ratio: number): Out;
	/**
	 * @en Check whether `Size` a is equal to `Size` b.
	 * @zh 判断两个尺寸是否相等。
	 * @param a Size a.
	 * @param b Size b.
	 * @returns Returns `true' when both dimensions are equal in width and height; otherwise returns `false'.
	 */
	static equals<InType extends ISizeLike>(a: InType, b: InType): boolean;
	set x(val: number);
	get x(): number;
	set y(val: number);
	get y(): number;
	width: number;
	height: number;
	/**
	 * @en Constructor a size from another one.
	 * @zh 构造与指定尺寸相等的尺寸。
	 * @param other Specified Size.
	 */
	constructor(other: Size);
	/**
	 * @en Constructor a size with specified values.
	 * @zh 构造具有指定宽度和高度的尺寸。
	 * @param width width of the Size, default value is 0.
	 * @param height height of the Size, default value is 0.
	 */
	constructor(width?: number, height?: number);
	/**
	 * @en clone the current `Size`.
	 * @zh 克隆当前尺寸。
	 */
	clone(): Size;
	/**
	 * @en Set values with another `Size`.
	 * @zh 设置当前尺寸使其与指定的尺寸相等。
	 * @param other Specified Size.
	 * @returns `this`
	 */
	set(other: Size): any;
	/**
	 * @en Set the value of each component of the current `Size`.
	 * @zh 设置当前尺寸的具体参数。
	 * @param width Specified width
	 * @param height Specified height
	 * @returns `this`
	 */
	set(width?: number, height?: number): any;
	/**
	 * @en Check whether the current `Size` equals another one.
	 * @zh 判断当前尺寸是否与指定尺寸的相等。
	 * @param other Specified Size
	 * @returns Returns `true' when both dimensions are equal in width and height; otherwise returns `false'.
	 */
	equals(other: Size): boolean;
	/**
	 * @en Calculate the interpolation result between this size and another one with given ratio
	 * @zh 根据指定的插值比率，从当前尺寸到目标尺寸之间做插值。
	 * @param to Target Size.
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	lerp(to: Size, ratio: number): Size;
	/**
	 * @en Return the information of the current size in string
	 * @zh 返回当前尺寸的字符串表示。
	 * @returns The information of the current size in string
	 */
	toString(): string;
}
/**
 * @en Constructs a `Size` object.
 * @zh 等价于 `new Size(other)`。
 * @param other Specified Size.
 * @returns `new Size(other)`
 */
export declare function size(other: Size): Size;
/**
 * @en Constructs a `Size` object.
 * @zh 等价于 `new Size(x, y)`。
 * @param width Specified width
 * @param height Specified height
 * @returns `new Size(w, h)`
 */
export declare function size(width?: number, height?: number): Size;
/**
 * @en
 * A 2D rectangle defined by x, y position at the bottom-left corner and width, height.
 * All points inside the rectangle are greater than or equal to the minimum point and less than or equal to the maximum point.
 * The width is defined as xMax - xMin and the height is defined as yMax - yMin.
 * @zh
 * 该类表示一个二维矩形，由其左下角的 x、y 坐标以及宽度和高度组成。
 * 矩形内的所有点都大于等于矩形的最小点 (xMin, yMin) 并且小于等于矩形的最大点 (xMax, yMax)。
 * 矩形的宽度定义为 xMax - xMin；高度定义为 yMax - yMin。
 */
export declare class Rect {
	/**
	 * @en Creates a rectangle from two coordinate values.
	 * @zh 由任意两个点创建一个矩形，目标矩形即是这两个点各向 x、y 轴作线所得到的矩形。
	 * @param v1 Specified point 1.
	 * @param v2 Specified point 2.
	 * @returns Target rectangle.
	 */
	static fromMinMax<Out extends IRectLike, VecLike extends IVec2Like>(out: Out, v1: VecLike, v2: VecLike): Out;
	/**
	 * @en Calculate the interpolation result between this rect and another one with given ratio
	 * @zh 根据指定的插值比率，从当前矩形到目标矩形之间做插值。
	 * @param out Output rect.
	 * @param from Original rect.
	 * @param to Target rect.
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	static lerp<Out extends IRectLike>(out: Out, from: Out, to: Out, ratio: number): Out;
	/**
	 * @en Returns the overlapping portion of 2 rectangles.
	 * @zh 计算当前矩形与指定矩形重叠部分的矩形，将其赋值给输出矩形。
	 * @param out Output Rect.
	 * @param one One of the specify Rect.
	 * @param other Another of the specify Rect.
	 */
	static intersection<Out extends IRectLike>(out: Out, one: Out, other: Out): Out;
	/**
	 * @en Returns the smallest rectangle that contains the current rect and the given rect.
	 * @zh 创建同时包含当前矩形和指定矩形的最小矩形，将其赋值给输出矩形。
	 * @param out Output Rect.
	 * @param one One of the specify Rect.
	 * @param other Another of the specify Rect.
	 */
	static union<Out extends IRectLike>(out: Out, one: Out, other: Out): Out;
	/**
	 * @en Returns whether rect a is equal to rect b.
	 * @zh 判断两个矩形是否相等。
	 * @param a The first rect to be compared.
	 * @param b The second rect to be compared.
	 * @returns Returns `true' when the minimum and maximum values of both rectangles are equal, respectively; otherwise, returns `false'.
	 */
	static equals<InType extends IRectLike>(a: InType, b: InType): boolean;
	/**
	 * @en The minimum x value.
	 * @zh 获取或设置矩形在 x 轴上的最小值。
	 */
	get xMin(): number;
	set xMin(value: number);
	/**
	 * @en The minimum y value.
	 * @zh 获取或设置矩形在 y 轴上的最小值。
	 */
	get yMin(): number;
	set yMin(value: number);
	/**
	 * @en The maximum x value.
	 * @zh 获取或设置矩形在 x 轴上的最大值。
	 */
	get xMax(): number;
	set xMax(value: number);
	/**
	 * @en The maximum y value.
	 * @zh 获取或设置矩形在 y 轴上的最大值。
	 */
	get yMax(): number;
	set yMax(value: number);
	/**
	 * @en The position of the center of the rectangle.
	 * @zh 获取或设置矩形中心点的坐标。
	 */
	get center(): Vec2;
	set center(value: Vec2);
	/**
	 * @en Returns a new [[Vec2]] object representing the position of the rectangle
	 * @zh 获取或设置矩形的 x 和 y 坐标。
	 */
	get origin(): Vec2;
	set origin(value: Vec2);
	/**
	 * @en Returns a new [[Size]] object represents the width and height of the rectangle
	 * @zh 获取或设置矩形的尺寸。
	 */
	get size(): Size;
	set size(value: Size);
	set z(val: number);
	get z(): number;
	set w(val: number);
	get w(): number;
	/**
	 * @en The minimum x value.
	 * @zh 矩形最小点的 x 坐标。
	 */
	x: number;
	/**
	 * @en The minimum y value.
	 * @zh 矩形最小点的 y 坐标。
	 */
	y: number;
	/**
	 * @en The width of the Rect.
	 * @zh 矩形的宽度。
	 */
	width: number;
	/**
	 * @en The height of the Rect.
	 * @zh 矩形的高度。
	 */
	height: number;
	/**
	 * @en Constructs a Rect from another one.
	 * @zh 构造与指定矩形相等的矩形。
	 * @param other Specified Rect.
	 */
	constructor(other: Rect);
	/**
	 * @en Constructs a Rect with specified values.
	 * @zh 构造具有指定的最小值和尺寸的矩形。
	 * @param x The minimum X coordinate of the rectangle.
	 * @param y The minimum Y coordinate of the rectangle.
	 * @param width The width of the rectangle, measured from the X position.
	 * @param height The height of the rectangle, measured from the Y position.
	 */
	constructor(x?: number, y?: number, width?: number, height?: number);
	/**
	 * @en clone the current Rect.
	 * @zh 克隆当前矩形。
	 */
	clone(): Rect;
	/**
	 * @en Set values with another Rect.
	 * @zh 设置当前矩形使其与指定矩形相等。
	 * @param other Specified Rect.
	 * @returns `this`
	 */
	set(other: Rect): any;
	/**
	 * @en Set the value of each component of the current Rect.
	 * @zh 设置当前矩形使其与指定参数的矩形相等。
	 * @param x The x parameter of the specified rectangle
	 * @param y The y parameter of the specified rectangle
	 * @param width The width parameter of the specified rectangle
	 * @param height The height parameter of the specified rectangle
	 * @returns `this`
	 */
	set(x?: number, y?: number, width?: number, height?: number): any;
	/**
	 * @en Check whether the current Rect equals another one.
	 * @zh 判断当前矩形是否与指定矩形相等。
	 * @param other Specified rectangles.
	 * @returns Returns `true' when the minimum and maximum values of both rectangles are equal, respectively; otherwise, returns `false'.
	 */
	equals(other: Rect): boolean;
	/**
	 * @en Calculate the interpolation result between this Rect and another one with given ratio.
	 * @zh 根据指定的插值比率，从当前矩形到目标矩形之间做插值。
	 * @param to Target Rect.
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	lerp(to: Rect, ratio: number): Rect;
	/**
	 * @en Return the information of the current rect in string
	 * @zh 返回当前矩形的字符串表示。
	 * @returns The information of the current rect in string
	 */
	toString(): string;
	/**
	 * @en Check whether the current rectangle intersects with the given one.
	 * @zh 判断当前矩形是否与指定矩形相交。
	 * @param other Specified rectangles.
	 * @returns If intersected, return `true', otherwise return `false'.
	 */
	intersects(other: Rect): boolean;
	/**
	 * @en Check whether the current rect contains the given point.
	 * @zh 判断当前矩形是否包含指定的点。
	 * @param point Specified point.
	 * @returns The specified point is included in the rectangle and returns `true', otherwise it returns `false'.
	 */
	contains(point: Vec2): boolean;
	/**
	 * @en Returns true if the other rect entirely inside this rectangle.
	 * @zh 判断当前矩形是否包含指定矩形。
	 * @param other Specified rectangles.
	 * @returns Returns `true' if all the points of the specified rectangle are included in the current rectangle, `false' otherwise.
	 */
	containsRect(other: Rect): boolean;
	/**
	 * @en Apply matrix4 to the rect.
	 * @zh
	 * 应用矩阵变换到当前矩形：
	 * 应用矩阵变换到当前矩形的最小点得到新的最小点，
	 * 将当前矩形的尺寸视为二维向量应用矩阵变换得到新的尺寸；
	 * 并将如此构成的新矩形。
	 * @param matrix The matrix4
	 */
	transformMat4(mat: Mat4): Rect;
	/**
	 * @en
	 * Applies a matrix transformation to the current rectangle and outputs the result to the four vertices.
	 * @zh
	 * 应用矩阵变换到当前矩形，并将结果输出到四个顶点上。
	 *
	 * @param mat The mat4 to apply
	 * @param out_lb The left bottom point
	 * @param out_lt The left top point
	 * @param out_rb The right bottom point
	 * @param out_rt The right top point
	 */
	transformMat4ToPoints(mat: Mat4, out_lb: Vec2, out_lt: Vec2, out_rt: Vec2, out_rb: Vec2): void;
}
/**
 * @en The convenient method to create a new Rect.
 * @zh 构造与指定矩形相等的矩形。等价于 `new Rect(rect)`。
 * @param rect Specified Rect.
 * @returns `new Rect(rect)`
 */
export declare function rect(rect: Rect): Rect;
/**
 * @en The convenient method to create a new Rect.
 * @zh 构造具有指定的最小值和尺寸的矩形，等价于`new Rect(x, y, width, height)`。
 * @param x The minimum X coordinate of the rectangle.
 * @param y The minimum Y coordinate of the rectangle.
 * @param width The width of the rectangle, measured from the X position.
 * @param height The height of the rectangle, measured from the Y position.
 * @returns `new Rect(x, y, width, height)`
 */
export declare function rect(x?: number, y?: number, width?: number, height?: number): Rect;
/**
 * @en `AffineTransform` class represent an affine transform matrix. It's composed basically by translation, rotation, scale transformations.
 * @zh 二维仿射变换矩阵，描述了平移、旋转和缩放。
 */
export declare class AffineTransform {
	/**
	 * @en Create an identity transformation matrix.
	 * @zh 创建单位二维仿射变换矩阵，它不进行任何变换。
	 */
	static identity(): AffineTransform;
	/**
	 * @en Clone an `AffineTransform` object from the specified transform.
	 * @zh 克隆指定的二维仿射变换矩阵。
	 * @param affineTransform Specified `AffineTransform` objects
	 */
	static clone(affineTransform: AffineTransform): AffineTransform;
	/**
	 * @en Concatenate a transform matrix to another. The results are reflected in the out `AffineTransform`.
	 * First apply t1, then t2: out * v = t2 * (t1 * v).
	 * @zh 将两个矩阵相乘的结果赋值给输出矩阵，先应用t1再应用t2: out * v = t2 * (t1 * v)。
	 * @param out Out object to store the concat result
	 * @param t1 The first transform object.
	 * @param t2 The transform object to concatenate.
	 */
	static concat(out: AffineTransform, t1: AffineTransform, t2: AffineTransform): void;
	/**
	 * @en Get the invert transform of an `AffineTransform` object.
	 * @zh 将矩阵求逆的结果赋值给输出矩阵。
	 * @param out Out object to store the invert result
	 * @param t the input `AffineTransform` object
	 */
	static invert(out: AffineTransform, t: AffineTransform): void;
	/**
	 * @en Get an `AffineTransform` object from a given matrix 4x4.
	 * @zh 将四维矩阵转换为二维仿射变换矩阵并赋值给输出矩阵。
	 * @param out The output matrix to store the result
	 * @param mat transform matrix.
	 */
	static fromMat4(out: AffineTransform, mat: Mat4): void;
	/**
	 * @en Apply the `AffineTransform` on a 2D vector.
	 * @zh 应用二维仿射变换矩阵到二维向量上，并将结果赋值给输出向量。
	 * @param out The output vector to store the result
	 * @param point Vector to apply transform.
	 * @param t transform matrix.
	 */
	static transformVec2(out: Vec2, point: Vec2, t: AffineTransform): any;
	/**
	 * @en Apply the `AffineTransform` on a 2D vector.
	 * @zh 应用二维仿射变换矩阵到二维向量上，并将结果赋值给输出向量。
	 * @param out The output vector to store the result
	 * @param x x to apply transform.
	 * @param y y to apply transform.
	 * @param t transform matrix.
	 */
	static transformVec2(out: Vec2, x: number, y: number, t: AffineTransform): any;
	/**
	 * @en Apply the `AffineTransform` on a size.
	 * @zh 应用二维仿射变换矩阵到二维尺寸上，并将结果赋值给输出尺寸。
	 * @param out The output size to store the result
	 * @param size The size to apply transform.
	 * @param t transform matrix.
	 */
	static transformSize(out: Size, size: Size, t: AffineTransform): void;
	/**
	 * @en Apply the `AffineTransform` on a rect.
	 * @zh 应用二维仿射变换矩阵到矩形上，并将结果赋值给输出矩形。
	 * @param out The output rect object to store the result
	 * @param rect The rect object to apply transform.
	 * @param t transform matrix.
	 */
	static transformRect(out: Rect, rect: Rect, t: AffineTransform): void;
	/**
	 * @en Apply the `AffineTransform` on a rect, and turns to an Oriented Bounding Box.
	 * This function does not allocate any memory, you should create the output vectors by yourself and manage their memory.
	 * @zh 应用二维仿射变换矩阵到矩形上, 并转换为有向包围盒。
	 * 这个函数不创建任何内存，你需要先创建包围盒的四个 Vector 对象用来存储结果，并作为前四个参数传入函数。
	 * @param out_bl Output vector for storing the bottom left corner coordinates of the Obb object
	 * @param out_tl Output vector for storing the top left corner coordinates of the Obb object
	 * @param out_tr Output vector for storing the top right corner coordinates of the Obb object
	 * @param out_br Output vector for storing the bottom right corner coordinates of the Obb object
	 * @param rect The rect object to apply transform.
	 * @param anAffineTransform transform matrix.
	 */
	static transformObb(out_bl: Vec2, out_tl: Vec2, out_tr: Vec2, out_br: Vec2, rect: Rect, anAffineTransform: AffineTransform, flipY?: boolean): void;
	/**
	 * matrix layout
	 * |a  c  tx|
	 * |b  d  ty|
	 * |0  0  1 |
	 */
	a: number;
	b: number;
	c: number;
	d: number;
	tx: number;
	ty: number;
	/**
	 * @en constructor an `AffineTransform` object.
	 * @zh 构造二维放射变换矩阵。
	 * @param a a
	 * @param b b
	 * @param c c
	 * @param d d
	 * @param tx tx
	 * @param ty ty
	 */
	constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
}
/**
 * @en Representation of RGBA colors.<br/>
 * Each color component is an integer value with a range from 0 to 255.<br/>
 * @zh 通过 Red、Green、Blue 颜色通道表示颜色，并通过 Alpha 通道表示不透明度。<br/>
 * 每个通道都为取值范围 [0, 255] 的整数。<br/>
 */
export declare class Color {
	static WHITE: Readonly<Color>;
	static GRAY: Readonly<Color>;
	static BLACK: Readonly<Color>;
	static TRANSPARENT: Readonly<Color>;
	static RED: Readonly<Color>;
	static GREEN: Readonly<Color>;
	static BLUE: Readonly<Color>;
	static CYAN: Readonly<Color>;
	static MAGENTA: Readonly<Color>;
	static YELLOW: Readonly<Color>;
	/**
	 * @en Copy content of a color into another and save the results to out color.
	 * @zh 获得指定颜色的拷贝
	 */
	static clone<Out extends IColorLike>(a: Out): Color;
	/**
	 * @en Clone a color and save the results to out color.
	 * @zh 复制目标颜色
	 */
	static copy<Out extends IColorLike>(out: Out, a: Out): Out;
	/**
	 * @en Set the components of a color to the given values and save the results to out color.
	 * @zh 设置颜色值
	 */
	static set<Out extends IColorLike>(out: Out, r: number, g: number, b: number, a: number): Out;
	/**
	 * @en Convert linear color from rgb8 0~255 to Vec4 0~1
	 * @zh 将当前颜色转换为到 Vec4
	 * @returns Vec4 as float color value
	 * @example
	 * ```
	 * const color = Color.YELLOW;
	 * color.toVec4();
	 * ```
	 */
	static toVec4(color: Color, out?: Vec4): Vec4;
	/**
	 * @en Convert 8bit linear color from Vec4
	 * @zh 使用 Vec4 设置 8 bit 颜色
	 * @returns 8 Bit srgb value
	 * @example
	 * ```
	 * color.fromVec4(new Vec4(1,1,1,1));
	 * ```
	 */
	static fromVec4(value: Vec4, out?: Color): Color;
	/**
	 * @en Converts the hexadecimal formal color into rgb formal and save the results to out color.
	 * @zh 从十六进制颜色字符串中读入颜色到 out 中
	 */
	static fromHEX<Out extends IColorLike>(out: Out, hexString: string): Out;
	/**
	 * @en Add two colors by components. And save the results to out color.
	 * @zh 逐通道颜色加法
	 */
	static add<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Subtract each components of color b from each components of color a. And save the results to out color.
	 * @zh 逐通道颜色减法
	 */
	static subtract<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Multiply each components of two colors. And save the results to out color.
	 * @zh 逐通道颜色乘法
	 */
	static multiply<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Divide each components of color a by each components of color b. And save the results to out color.
	 * @zh 逐通道颜色除法
	 */
	static divide<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
	/**
	 * @en Multiply all channels in a color with the given scale factor, and save the results to out color.
	 * @zh 全通道统一缩放颜色
	 */
	static scale<Out extends IColorLike>(out: Out, a: Out, b: number): Out;
	/**
	 * @en Performs a linear interpolation between two colors.
	 * @zh 逐通道颜色线性插值：A + t * (B - A)
	 */
	static lerp<Out extends IColorLike>(out: Out, from: Out, to: Out, ratio: number): Out;
	/**
	 * @en Convert a color object to a RGBA array, and save the results to out color.
	 * @zh 颜色转数组
	 * @param ofs Array Start Offset
	 */
	static toArray<Out extends Array<number>>(out: Out, a: IColorLike, ofs?: number): Out;
	/**
	 * @en Sets the given color with RGBA values in an array, and save the results to out color.
	 * @zh 数组转颜色
	 * @param ofs Array Start Offset
	 */
	static fromArray<Out extends IColorLike>(arr: Array<number>, out: Out, ofs?: number): Out;
	/**
	 * @zh 从无符号 32 位整数构造颜色，高 8 位为 alpha 通道，次高 8 位为蓝色通道，次低 8 位为绿色通道，低 8 位为红色通道。
	 * @en Construct color from a unsigned 32 bit integer, the highest 8 bits is for alpha channel, the second highest 8 bits is for blue channel,
	 * the second lowest 8 bits is for green channel, and the lowest 8 bits if for red channel.
	 *
	 * @param out @en Output color object. @zh 输出的颜色对象。
	 * @param uint32 @en The unsigned 32 bit integer @zh 32 位无符号整数
	 * @returns @en The `out` object @zh `out` 对象
	 */
	static fromUint32<Out extends IColorLike>(out: Out, uint32: number): Out;
	/**
	 * @zh 转换当前颜色为无符号 32 位整数, 高 8 位为 alpha 通道，次高 8 位为蓝色通道，次低 8 位为绿色通道，低 8 位为红色通道。
	 * @en Convert the current color to a unsigned 32 bit integer, the highest 8 bits is for alpha channel,
	 * the second highest 8 bits is for blue channel, the second lowest 8 bits is for green channel, and the lowest 8 bits if for red channel.
	 *
	 * @param color @en The color. @zh 颜色。
	 * @returns @en The converted unsigned 32 bit integer. @zh 32 位无符号整数。
	 */
	static toUint32(color: IColorLike): number;
	/**
	 * @en Check whether the two given colors are identical
	 * @zh 颜色等价判断
	 */
	static strictEquals<Out extends IColorLike>(a: Out, b: Out): boolean;
	/**
	 * @en Check whether the two given colors are approximately equivalent. Difference of each channel is smaller that the epsilon.
	 * @zh 排除浮点数误差的颜色近似等价判断
	 */
	static equals<Out extends IColorLike>(a: Out, b: Out, epsilon?: number): boolean;
	/**
	 * @en Convert the given color to a hex color value. And save the results to out color.
	 * @zh 获取指定颜色的整型数据表示
	 */
	static hex<Out extends IColorLike>(a: Out): number;
	/**
	 * @en Get or set red channel value.
	 * @zh 获取或设置当前颜色的 Red 通道。
	 */
	get r(): number;
	set r(red: number);
	/**
	 * @en Get or set green channel value.
	 * @zh 获取或设置当前颜色的 Green 通道。
	 */
	get g(): number;
	set g(green: number);
	/**
	 * @en Get or set blue channel value.
	 * @zh 获取或设置当前颜色的 Blue 通道。
	 */
	get b(): number;
	set b(blue: number);
	/** @en Get or set alpha channel value.
	 * @zh 获取或设置当前颜色的透明度通道。
	 */
	get a(): number;
	set a(alpha: number);
	get x(): number;
	set x(value: number);
	get y(): number;
	set y(value: number);
	get z(): number;
	set z(value: number);
	get w(): number;
	set w(value: number);
	/**
	 * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
	 */
	_val: number;
	/**
	 * @en Construct a same color from the given color
	 * @zh 构造与指定颜色相等的颜色。
	 * @param other Specified color
	 */
	constructor(other: Color);
	/**
	 * @en Construct a color form the hex color string
	 * @zh 用十六进制颜色字符串中构造颜色。
	 * @param hexString Hexadecimal color string.
	 */
	constructor(hexString: string);
	/**
	 * @en Construct a color
	 * @zh 构造具有指定通道的颜色。
	 * @param r red component of the color, default value is 0.
	 * @param g green component of the color, default value is 0.
	 * @param b blue component of the color, default value is 0.
	 * @param a alpha component of the color, default value is 255.
	 */
	constructor(r?: number, g?: number, b?: number, a?: number);
	/**
	 * @en Clone a new color from the current color.
	 * @zh 克隆当前颜色。
	 */
	clone(): Color;
	/**
	 * @en Check whether the current color is identical with the given color
	 * @zh 判断当前颜色是否与指定颜色相等。
	 * @param other Specified color
	 * @returns Returns `true` when all channels of both colours are equal; otherwise returns `false`.
	 */
	equals(other: Color): boolean;
	/**
	 * @en Calculate linear interpolation result between this color and another one with given ratio。
	 * @zh 根据指定的插值比率，从当前颜色到目标颜色之间做插值。
	 * @param to Target color
	 * @param ratio The interpolation coefficient.The range is [0,1].
	 */
	lerp(to: Color, ratio: number): Color;
	/**
	 * @en Convert to string with color informations
	 * @zh 返回当前颜色的字符串表示。
	 * @returns A string representation of the current color.
	 */
	toString(): string;
	/**
	 * @en Convert color to css format.
	 * @zh 将当前颜色转换为 CSS 格式。
	 * @param opt "rgba", "rgb", "#rgb" or "#rrggbb".
	 * @returns CSS format for the current color.
	 * @example
	 * ```ts
	 * let color = cc.Color.BLACK;
	 * color.toCSS();          // "rgba(0,0,0,1.00)";
	 * color.toCSS("rgba");    // "rgba(0,0,0,1.00)";
	 * color.toCSS("rgb");     // "rgba(0,0,0)";
	 * color.toCSS("#rgb");    // "#000";
	 * color.toCSS("#rrggbb"); // "#000000";
	 * ```
	 */
	toCSS(opt?: ("rgba" | "rgb" | "#rrggbb" | "#rrggbbaa")): string;
	/**
	 * @en Read hex string and store color data into the current color object, the hex string must be formatted as rgba or rgb.
	 * @zh 从十六进制颜色字符串中读入当前颜色。<br/>
	 * 十六进制颜色字符串应该以可选的 "#" 开头，紧跟最多 8 个代表十六进制数字的字符；<br/>
	 * 每两个连续字符代表的数值依次作为 Red、Green、Blue 和 Alpha 通道；<br/>
	 * 缺省的颜色通道将视为 0；缺省的透明通道将视为 255。<br/>
	 * @param hexString the hex string
	 * @returns `this`
	 */
	fromHEX(hexString: string): Color;
	/**
	 * @en convert Color to HEX color string.
	 * @zh 转换当前颜色为十六进制颜色字符串。
	 * @param fmt "#rrggbb" or "#rrggbbaa".
	 * - `'#rrggbbaa'` obtains the hexadecimal value of the Red, Green, Blue, Alpha channels (**two**, high complement 0) and connects them sequentially.
	 * - `'#rrggbb'` is similar to `'#rrggbbaa'` but does not include the Alpha channel.
	 * @returns the Hex color string
	 * @example
	 * ```
	 * const color = new Color(255, 14, 0, 255);
	 * color.toHEX("#rgb");      // "f00";
	 * color.toHEX("#rrggbbaa"); // "ff0e00ff"
	 * color.toHEX("#rrggbb");   // "ff0e00"
	 * ```
	 */
	toHEX(fmt?: "#rgb" | "#rrggbb" | "#rrggbbaa"): string;
	/**
	 * @en Convert to rgb value.
	 * @zh 将当前颜色转换为 RGB 整数值。
	 * @returns RGB integer value. Starting from the lowest valid bit, each 8 bits is the value of the Red, Green, and Blue channels respectively.
	 * @example
	 * ```
	 * const color = Color.YELLOW;
	 * color.toRGBValue();
	 * ```
	 */
	toRGBValue(): number;
	/**
	 * @en Read HSV model color and convert to RGB color.
	 * @zh 从 HSV 颜色中读入当前颜色。
	 * @param h H value。
	 * @param s S value。
	 * @param v V value。
	 * @returns `this`
	 * @example
	 * ```
	 * const color = Color.YELLOW;
	 * color.fromHSV(0, 0, 1); // Color {r: 255, g: 255, b: 255, a: 255};
	 * ```
	 */
	fromHSV(h: number, s: number, v: number): Color;
	/**
	 * @en Transform to HSV model color.
	 * @zh 转换当前颜色为 HSV 颜色。
	 * @returns HSV format color
	 * @example
	 * ```
	 * import { Color } from 'cc';
	 * const color = Color.YELLOW;
	 * color.toHSV(); // {h: 0.1533864541832669, s: 0.9843137254901961, v: 1}
	 * ```
	 */
	toHSV(): {
		h: number;
		s: number;
		v: number;
	};
	/**
	 * @en Set the color.
	 * @zh 设置当前颜色使其与指定颜色相等。
	 * @param other The specified color.
	 * @overload
	 * @param [r=0] red component of the color, the range is [0-255]
	 * @param [g=0] green component of the color
	 * @param [b=0] blue component of the color
	 * @param [a=255] alpha component of the color
	 * @returns Current color.
	 */
	set(other: Color): Color;
	set(r?: number, g?: number, b?: number, a?: number): Color;
	/**
	 * @en Multiplies the current color by the specified color.
	 * @zh 将当前颜色乘以与指定颜色
	 * @param other The specified color.
	 */
	multiply(other: Color): Color;
	/**
	 * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
	 */
	_set_r_unsafe(red: number): Color;
	/**
	 * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
	 */
	_set_g_unsafe(green: number): Color;
	/**
	 * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
	 */
	_set_b_unsafe(blue: number): Color;
	/**
	 * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
	 */
	_set_a_unsafe(alpha: number): Color;
}
export declare function color(other: Color | string): Color;
export declare function color(r?: number, g?: number, b?: number, a?: number): Color;
export declare const HALF_PI: number;
export declare const TWO_PI: number;
export declare const EPSILON = 0.000001;
/**
 * @en Tests whether or not the arguments have approximately the same value, within an absolute<br/>
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less<br/>
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * @zh 在glMatrix的绝对或相对容差范围内，测试参数是否具有近似相同的值。<br/>
 * EPSILON(小于等于1.0的值采用绝对公差，大于1.0的值采用相对公差)
 * @param a The first number to test.
 * @param b The second number to test.
 * @return True if the numbers are approximately equal, false otherwise.
 */
export declare function equals(a: number, b: number): boolean;
/**
 * @en Tests whether or not the arguments have approximately the same value by given maxDiff<br/>
 * @zh 通过给定的最大差异，测试参数是否具有近似相同的值。
 * @param a The first number to test.
 * @param b The second number to test.
 * @param maxDiff Maximum difference.
 * @return True if the numbers are approximately equal, false otherwise.
 */
export declare function approx(a: number, b: number, maxDiff?: number): boolean;
/**
 * @en Clamps a value between a minimum float and maximum float value.<br/>
 * @zh 返回最小浮点数和最大浮点数之间的一个数值。可以使用 clamp 函数将不断变化的数值限制在范围内。
 * @param val
 * @param min
 * @param max
 */
export declare function clamp(val: number, min: number, max: number): number;
/**
 * @en Clamps a value between 0 and 1.<br/>
 * @zh 将值限制在0和1之间。
 * @param val
 */
export declare function clamp01(val: number): number;
/**
 * @en Linear interpolation between two numbers
 * @zh 两个数之间的线性插值。
 * @param from - The starting number.
 * @param to - The ending number.
 * @param ratio - The interpolation coefficient, t should be in the range [0, 1].
 */
export declare function lerp(from: number, to: number, ratio: number): number;
/**
 * @en Convert Degree To Radian<br/>
 * @zh 把角度换算成弧度。
 * @param {Number} a Angle in Degrees
 */
export declare function toRadian(a: number): number;
/**
 * @en Convert Radian To Degree<br/>
 * @zh 把弧度换算成角度。
 * @param {Number} a Angle in Radian
 */
export declare function toDegree(a: number): number;
/**
 * @method random
 */
export declare function random(): number;
/**
 * @en Set a custom random number generator, default to Math.random
 * @zh 设置自定义随机数生成器，默认为 Math.random
 * @param func custom random number generator
 */
export declare function setRandGenerator<TFunction extends (...any: any[]) => number>(func: TFunction): void;
/**
 * @en Returns a floating-point random number between min (inclusive) and max (exclusive).<br/>
 * @zh 返回最小(包含)和最大(不包含)之间的浮点随机数。
 * @method randomRange
 * @param min
 * @param max
 * @return {Number} The random number.
 */
export declare function randomRange(min: number, max: number): number;
/**
 * @en Returns a random integer between min (inclusive) and max (exclusive).<br/>
 * @zh 返回最小(包含)和最大(不包含)之间的随机整数。
 * @param min
 * @param max
 * @return The random integer.
 */
export declare function randomRangeInt(min: number, max: number): number;
/**
 * @en
 * Linear congruence generator using Hull-Dobell Theorem.
 * @zh
 * 使用 Hull-Dobell 算法的线性同余生成器构造伪随机数
 *
 * @param seed The random seed.
 * @return The pseudo random.
 */
export declare function pseudoRandom(seed: number): number;
/**
 * @en
 * Returns a floating-point pseudo-random number between min (inclusive) and max (exclusive).
 * @zh
 * 返回一个在范围内的浮点伪随机数，注意，不包含边界值
 *
 * @param seed
 * @param min
 * @param max
 * @return The random number.
 */
export declare function pseudoRandomRange(seed: number, min: number, max: number): number;
/**
 * @en Returns a pseudo-random integer between min (inclusive) and max (exclusive).<br/>
 * @zh 返回最小(包含)和最大(不包含)之间的浮点伪随机数。
 * @param seed
 * @param min
 * @param max
 * @return The random integer.
 */
export declare function pseudoRandomRangeInt(seed: number, min: number, max: number): number;
/**
 * @en
 * Returns the next power of two for the value.<br/>
 * @zh
 * 返回下一个最接近的 2 的幂
 *
 * @param val
 * @return The the next power of two.
 */
export declare function nextPow2(val: number): number;
/**
 * @en Returns float remainder for t / length.<br/>
 * @zh 返回t / length的浮点余数。
 * @param t Time start at 0.
 * @param length Time of one cycle.
 * @return The Time wrapped in the first cycle.
 */
export declare function repeat(t: number, length: number): number;
/**
 * @en
 * Returns time wrapped in ping-pong mode.
 * @zh
 * 返回乒乓模式下的相对时间
 *
 * @param t Time start at 0.
 * @param length Time of one cycle.
 * @return The time wrapped in the first cycle.
 */
export declare function pingPong(t: number, length: number): number;
/**
 * @en Returns ratio of a value within a given range.<br/>
 * @zh 返回给定范围内的值的比率。
 * @param from Start value.
 * @param to End value.
 * @param value Given value.
 * @return The ratio between [from, to].
 */
export declare function inverseLerp(from: number, to: number, value: number): number;
/**
 * @en Compare the absolute values of all components and the component with the largest absolute value will be returned.
 * @zh 对所有分量的绝对值进行比较大小，返回绝对值最大的分量。
 * @param v vec3 like value
 * @returns max absolute component
 */
export declare function absMaxComponent(v: IVec3Like): number;
/**
 * @en Compare the absolute value of two values and return the value with the largest absolute value
 * @zh 对 a b 的绝对值进行比较大小，返回绝对值最大的值。
 * @param a number
 * @param b number
 */
export declare function absMax(a: number, b: number): number;
/**
 * @en
 * Make the attributes of the specified class available to be enumerated
 * @zh
 * 使指定类的特定属性可被枚举
 * @param prototype Inherit the prototype chain of the ValueType class
 * @param attrs List of attributes that need to be enumerated
 */
export declare function enumerableProps(prototype: object, attrs: string[]): void;
export declare function floatToHalf(val: number): number;
export declare function halfToFloat(val: number): number;
export interface IAssetOperationHandle {
}
export interface IBundleAssetProvider {
	asset: Asset;
	releaseHandle(handle: IAssetOperationHandle): any;
	internalLoad(): any;
}
export declare class AssetOperationHandle {
	provider: IBundleAssetProvider;
	isDisposed: boolean;
	getAsset<T extends Asset>(assetType: Type<T>): T;
	dispose(): void;
	instantiateSync(): Node;
	instantiateAsync(): Promise<Node>;
}
declare class AssetSystem {
	/**
	 * 同时加载的最大数量
	 */
	private static _maxLoadingProvider;
	/**
	 * 每一帧最多添加几个到加载列表
	 */
	private static _frameMaxAddQueueProvider;
	private _waitLoads;
	private _loadingSet;
	private _frameAddCount;
	update(): void;
	addProvider(provider: IBundleAssetProvider): void;
	updateLoadingSet(): void;
	removeProvider(provider: IBundleAssetProvider): void;
}
declare class AssetInfo {
	bundleName: string;
	assetPath: string;
	assetType: Type<Asset>;
	uuid: string;
	init<T extends Asset>(assetType: Type<T>, location: string): void;
	private parseLocation;
}
export declare class BundleAsset {
	bundleName: string;
	bundle: AssetManager.Bundle;
	refCount: number;
	isAutoRelease: boolean;
	assetSystem: AssetSystem;
	private _providerMap;
	loadAssetAsync(assetInfo: AssetInfo): Promise<IAssetOperationHandle>;
	private createProvider;
	unloadUnusedAssets(): void;
}
export declare class MoyeAssets extends Singleton {
	static assetSystem: AssetSystem;
	private static readonly _bundleMap;
	private static readonly _bundlePathMap;
	awake(): void;
	update(): void;
	static loadAssetAsync<T extends Asset>(assetType: new () => T, location: string): Promise<AssetOperationHandle>;
	static loadBundleAsync(bundleName: string): Promise<BundleAsset>;
	static releaseBundle(bundleAsset: BundleAsset): void;
	static unloadUnusedAssets(): void;
}
/**
 * button async listener
 * wait for the callback to complete
 */
export declare class AsyncButtonListener {
	private _callback;
	private _isClick;
	constructor(func: ActionAnyArgs);
	invoke(...args: any[]): Promise<void>;
	static create(func: ActionAnyArgs): Action<void>;
}
export declare enum ViewLayer {
	/**
	 * 场景UI，如：点击建筑查看建筑信息---一般置于场景之上，界面UI之下
	 */
	SCENE = 1,
	/**
	 * 背景UI，如：主界面---一般情况下用户不能主动关闭，永远处于其它UI的最底层
	 */
	BACKGROUND = 2,
	/**
	 * 普通UI，一级、二级、三级等窗口---一般由用户点击打开的多级窗口
	 */
	NORMAL = 3,
	/**
	 * 信息UI---如：跑马灯、广播等---一般永远置于用户打开窗口顶层
	 */
	INFO = 4,
	/**
	 * 提示UI，如：错误弹窗，网络连接弹窗等
	 */
	TIPS = 5,
	/**
	 * 顶层UI，如：场景加载
	 */
	TOP = 6
}
export declare abstract class AMoyeView extends Entity {
	viewName: string;
	layer: ViewLayer;
	node: Node;
	private _viewMgr;
	/**
	 * on node load, this method will be called
	 */
	protected onLoad?(): void;
	/**
	 * on view visible, this method will be called
	 */
	protected onShow?(): void;
	/**
	 * on view invisible, this method will be called
	 */
	protected onHide?(): void;
	/**
	 * on node destroy, this method will be called
	 */
	protected destroy?(): void;
	/**
	 * the mothod can't get this.node, if you want get node on node load, use onLoad
	 */
	protected awake?(): void;
	private _realDispose;
	dispose(): void;
	bringToFront(): void;
}
export interface IMoyeViewConfig {
	/**
	 * after view hide, destroy view after expire(ms),
	 */
	expire: number;
	/**
	 * on view load, this method will be called, should return a node,
	 * @param viewName
	 */
	load(viewName: string): Promise<Node>;
	/**
	 * on view destroy, you can do some clean in this method,
	 */
	destroy(): void;
	/**
	 * before show do animation
	 * if animation done, you should call task.setResult()
	 * @param task
	 */
	doShowAnimation?(view: AMoyeView, task: Task): void;
	/**
	 * before hide do animation
	 * if animation done, you should call task.setResult()
	 * @param task
	 */
	doHideAnimation?(view: AMoyeView, task: Task): void;
}
export declare class MoyeViewMgr extends Entity {
	static inst: MoyeViewMgr;
	/**
	 * all views
	 */
	private _views;
	private _type2Names;
	private _showingViews;
	private _hideViews;
	private _viewCfgs;
	private _layers;
	private _globalViewCfgType;
	private _uiRoot;
	private _checkTimerId;
	private _checkInterval;
	protected awake(): void;
	protected destroy(): void;
	/**
	 * init view manager
	 * @param uiRoot
	 * @param globalViewCfg all field need to set
	 * @returns
	 */
	init(uiRoot: Node, globalViewCfg: Type<IMoyeViewConfig>): void | this;
	show<T extends AMoyeView>(type: Type<T>, bindEntity?: Entity): Promise<T>;
	show(name: string, bindEntity?: Entity): Promise<AMoyeView>;
	hide(name: string): Promise<void>;
	/**
	 * reload confog
	 */
	reload(): void;
	private check;
	private getLayerNode;
	private addToCleanCom;
	private enterViewShow;
	private enterViewHide;
	private enterViewDestroy;
}
export declare const ViewDecoratorType = "ViewDecorator";
export declare function ViewDecorator(name: string, layer: ViewLayer, viewCfg?: Type<IMoyeViewConfig>): (target: Type<AMoyeView>) => void;
export declare class SizeFollow extends Component {
	get target(): UITransform;
	set target(value: UITransform);
	private _target;
	set heightFollow(val: boolean);
	get heightFollow(): boolean;
	private _heightFollow;
	set widthFollow(val: boolean);
	get widthFollow(): boolean;
	private _widthFollow;
	private _heightOffset;
	private _widthOffset;
	private _changeSize;
	protected onLoad(): void;
	protected onDestroy(): void;
	private onTargetSizeChange;
	private updateSizeOffset;
}
declare enum WidgetDirection {
	LEFT = 1,
	RIGHT = 2,
	TOP = 3,
	BOTTOM = 4,
	LEFT_EXTEND = 5,
	RIGHT_EXTEND = 6,
	TOP_EXTEND = 7,
	BOTTOM_EXTEND = 8
}
/**
 * 关联组件
 * 不允许直系亲属互相关联
 * 同父支持size跟pos关联
 * 异父仅支持pos关联 size关联未做测试
 */
export declare class CTWidget extends Component {
	get target(): UITransform;
	set target(value: UITransform);
	private _target;
	set targetDir(val: WidgetDirection);
	get targetDir(): WidgetDirection;
	private _targetDir;
	set dir(val: WidgetDirection);
	get dir(): WidgetDirection;
	private _dir;
	visibleOffset: number;
	private _isVertical;
	private _distance;
	private _changePos;
	private _targetOldPos;
	private _targetOldSize;
	private _selfOldPos;
	private _selfOldSize;
	private _trans;
	protected onEnable(): void;
	protected onDisable(): void;
	protected onLoad(): void;
	protected onDestroy(): void;
	private registerEvt;
	private unregisterEvt;
	private updateData;
	private onTargetChange;
	private updateSize;
	private updatePos;
	private updateTargetPos;
	private updateDistance;
	private getPos;
}
export declare class RoundBoxSprite extends UIRenderer {
	protected _sizeMode: import("cc").__private._cocos_2d_components_sprite__SizeMode;
	get sizeMode(): import("cc").__private._cocos_2d_components_sprite__SizeMode;
	set sizeMode(value: import("cc").__private._cocos_2d_components_sprite__SizeMode);
	protected _atlas: SpriteAtlas | null;
	get spriteAtlas(): SpriteAtlas;
	set spriteAtlas(value: SpriteAtlas);
	_segments: number;
	get segments(): number;
	set segments(segments: number);
	_radius: number;
	get radius(): number;
	set radius(radius: number);
	protected _spriteFrame: SpriteFrame | null;
	get spriteFrame(): SpriteFrame;
	set spriteFrame(value: SpriteFrame);
	protected _leftTop: boolean;
	get leftTop(): boolean;
	set leftTop(value: boolean);
	protected _rightTop: boolean;
	get rightTop(): boolean;
	set rightTop(value: boolean);
	protected _leftBottom: boolean;
	get leftBottom(): boolean;
	set leftBottom(value: boolean);
	protected _rightBottom: boolean;
	get rightBottom(): boolean;
	set rightBottom(value: boolean);
	onLoad(): void;
	__preload(): void;
	onEnable(): void;
	onDestroy(): void;
	/**
	 * @en
	 * Quickly switch to other sprite frame in the sprite atlas.
	 * If there is no atlas, the switch fails.
	 *
	 * @zh
	 * 选取使用精灵图集中的其他精灵。
	 * @param name @en Name of the spriteFrame to switch. @zh 要切换的 spriteFrame 名字。
	 */
	changeSpriteFrameFromAtlas(name: string): void;
	/**
	 * @deprecated Since v3.7.0, this is an engine private interface that will be removed in the future.
	 */
	changeMaterialForDefine(): void;
	protected _updateBuiltinMaterial(): Material;
	protected _render(render: any): void;
	protected _canRender(): boolean;
	protected resetAssembler(): void;
	protected _flushAssembler(): void;
	private _applySpriteSize;
	private _resized;
	private _activateMaterial;
	private _updateUVs;
	private _applySpriteFrame;
}
/**
 * 全局事件监听实例
 */
export declare const instance: import("cc").__private._cocos_core_event_event_target__Empty & import("cc").__private._cocos_core_event_eventify__IEventified;
export declare const SET_JOYSTICK_TYPE = "SET_JOYSTICK_TYPE";
/**
 * 方向类型
 */
export declare enum DirectionType {
	FOUR = 0,
	EIGHT = 1,
	ALL = 2
}
/**
 * 速度类型
 */
export declare enum SpeedType {
	STOP = 0,
	NORMAL = 1,
	FAST = 2
}
/**
 * 摇杆类型
 */
export declare enum JoystickType {
	FIXED = 0,
	FOLLOW = 1
}
export interface JoystickDataType {
	speedType: SpeedType;
	/**
	 * 移动向量
	 */
	moveVec: Vec3;
}
/**
 * 摇杆类
 */
export declare class YYJJoystick extends Component {
	dot: Node | null;
	ring: Node | null;
	joystickType: JoystickType;
	directionType: DirectionType;
	_stickPos: Vec3;
	_touchLocation: Vec2;
	radius: number;
	onLoad(): void;
	/**
	 * 启用时
	 */
	onEnable(): void;
	/**
	 * 禁用时
	 */
	onDisable(): void;
	/**
	 * 改变摇杆类型
	 * @param type
	 */
	_onSetJoystickType(type: JoystickType): void;
	/**
	 * 初始化触摸事件
	 */
	_initTouchEvent(): void;
	/**
	 * 触摸开始回调函数
	 * @param event
	 */
	_touchStartEvent(event: EventTouch): void;
	/**
	 * 触摸移动回调函数
	 * @param event
	 */
	_touchMoveEvent(event: EventTouch): boolean;
	/**
	 * 触摸结束回调函数
	 * @param event
	 */
	_touchEndEvent(event: EventTouch): void;
}
export interface IYYJJoystickEntity extends Entity {
	speedChange(type: SpeedType, speed: number): void;
	setPos(pos: Vec3): void;
	getPos(): Vec3;
	setAngle(angle: number): void;
}
export declare class YYJJoystickCom extends Entity {
	/**
	 * "移动方向"
	 */
	moveDir: Vec3;
	/**
	 * 速度级别
	 */
	private _speedType;
	/**
	 * 移动速度
	 */
	private _moveSpeed;
	/**
	 * 停止时速度
	 */
	stopSpeed: number;
	/**
	 * 正常速度
	 */
	normalSpeed: number;
	/**
	 * 最快速度
	 */
	fastSpeed: number;
	/**
	 * 是否设置角度
	 */
	isRotation: boolean;
	private _entity;
	init(entity: IYYJJoystickEntity): this;
	protected destroy(): void;
	onTouchStart(): void;
	onTouchMove(event: EventTouch, data: JoystickDataType): void;
	onTouchEnd(event: EventTouch, data: JoystickDataType): void;
	/**
	* set moveSpeed by SpeedType
	* @param speedType
	*/
	onSetMoveSpeed(speedType: SpeedType): void;
	/**
	 * 移动
	 */
	move(): void;
	update(): void;
}

export {};
