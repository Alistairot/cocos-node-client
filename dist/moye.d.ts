// Generated by dts-bundle-generator v8.0.1

import { Asset, AssetManager, Node } from 'cc';

/**
 * 构造函数
 */
export interface Type<T = any> extends Function {
	new (...args: any[]): T;
}
export interface ISceneInitArgs {
	id: bigint;
	instanceId?: bigint;
	sceneType: string;
	name: string;
	parent?: Entity;
}
export declare class Scene extends Entity {
	name: string;
	sceneType: string;
	set domain(value: Entity);
	get domain(): Entity;
	set parent(value: Entity);
	init(args: ISceneInitArgs): void;
}
export declare abstract class Entity {
	get parent(): Entity;
	set parent(value: Entity);
	get domain(): Entity;
	set domain(value: Entity);
	instanceId: bigint;
	id: bigint;
	get isDisposed(): boolean;
	get children(): Map<bigint, Entity>;
	get components(): Map<Type<Entity>, Entity>;
	protected _domain: Entity;
	private _children;
	private _components;
	protected _parent: Entity;
	private _status;
	private get isFromPool();
	private set isFromPool(value);
	private get isComponent();
	private set isComponent(value);
	protected get isCreated(): boolean;
	protected set isCreated(value: boolean);
	protected get isNew(): boolean;
	protected set isNew(value: boolean);
	protected get isRegister(): boolean;
	protected set isRegister(value: boolean);
	private set componentParent(value);
	addCom(component: Entity): Entity;
	addCom<T extends Entity>(type: Type<T>): T;
	addCom<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	/**
	 * if not exist com will add new
	 * @param type
	 * @returns
	 */
	tryAddCom<T extends Entity>(type: Type<T>): T;
	private addComByEntity;
	private addComByType;
	addChild(entity: Entity): Entity;
	addChild<T extends Entity>(type: Type<T>): T;
	addChild<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	addChildWithId<T extends Entity>(type: Type<T>, id: bigint, isFromPool?: boolean): T;
	private addChildByEntity;
	private addChildByType;
	private create;
	private removeFromChildren;
	private removeFromComponents;
	private addToComponents;
	private addToChildren;
	getCom<K extends Entity>(type: new () => K): K;
	removeCom<T extends Entity>(type: Type<T>): T;
	getParent<T extends Entity>(type: Type<T>): T;
	getChild<T extends Entity>(type: Type<T>, id: bigint): T;
	removeChild(id: bigint): void;
	dispose(): void;
	domainScene(): Scene;
	getType(): Type;
	protected awake?(): void;
	protected update?(): void;
	protected lateUpdate?(): void;
	protected destroy?(): void;
}
export declare enum SceneType {
	NONE = "NONE",
	PROCESS = "PROCESS",
	CLIENT = "CLIENT",
	CURRENT = "CURRENT"
}
/**
 * 单例基类
 */
export declare abstract class Singleton {
	private static _inst;
	private _isDisposed;
	static getInst<T extends Singleton>(this: new () => T): T;
	get isDisposed(): boolean;
	dispose(): void;
	protected destroy?(): void;
	private _onPreDestroy;
}
export declare class ObjectPool extends Singleton {
	private _pool;
	fetch<T>(type: Type<T>): T;
	recycle(obj: object): void;
}
/**
 * 可回收对象
 */
export declare abstract class RecycleObj {
	private _isRecycle;
	/**
	 * 通过对象池创建
	 * @param this
	 * @param values
	 * @returns
	 */
	static create<T extends RecycleObj>(this: Type<T>, values?: Partial<T>): T;
	/**
	 * 如果是通过create方法创建的
	 * 那么dispose会回收到对象池
	 */
	dispose(): void;
}
export interface ILog {
	log(str: string): void;
	warn(str: string): void;
	error(str: string): void;
}
/**
 * Logger
 */
export declare class Logger extends Singleton {
	set iLog(value: ILog);
	static readonly LOG_LEVEL = 1;
	static readonly WARN_LEVEL = 2;
	private _logInst;
	private get _iLog();
	log(str: string, ...args: any[]): void;
	warn(str: string, ...args: any[]): void;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	error(str: string, ...args: any[]): void;
	private checkLogLevel;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreLog;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreWarn;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	private coreError;
}
export declare function log(str: string, ...args: any[]): void;
export declare function warn(str: string, ...args: any[]): void;
export declare function error(str: string, ...args: any[]): void;
export declare class IdGenerator extends Singleton {
	generateInstanceId(): bigint;
	generateId(): bigint;
}
export declare class IdStruct {
	private static _lastTime;
	private static _idCount;
	private static _inst;
	private static get inst();
	time: bigint;
	process: bigint;
	value: bigint;
	result: bigint;
	static generate(): bigint;
	static convertToId(time: number, process: number, value: number): bigint;
	/**
	 * convert id to 3 args
	 * not reference return value
	 * @param id bigint
	 * @returns
	 */
	static parseId(id: bigint): IdStruct;
	private static timeSinceEpoch;
	/**
	 * convert id to 3 args
	 * @param id bigint
	 * @returns
	 */
	initById(id: bigint): this;
	init(time: number, process: number, value: number): this;
	private updateResult;
}
export declare class InstanceIdStruct {
	private static _lastTime;
	private static _idCount;
	private static _inst;
	private static get inst();
	time: bigint;
	value: bigint;
	result: bigint;
	static generate(): bigint;
	static convertToId(time: number, value: number): bigint;
	/**
	 * convert id to 2 args
	 * not reference return value
	 * @param id bigint
	 * @returns
	 */
	static parseId(id: bigint): InstanceIdStruct;
	private static timeSinceEpoch;
	/**
	 * convert id to 3 args
	 * @param id bigint
	 * @returns
	 */
	initById(id: bigint): this;
	init(time: number, value: number): this;
	private updateResult;
}
export declare class Program {
	static init(rootNode: Node): void;
	/**
	 * 确保所有脚本已经加载之后调用start
	 */
	static start(): void;
}
export declare class Game {
	private static _singletonMap;
	private static _singletons;
	private static _destroys;
	private static _updates;
	private static _lateUpdates;
	private static _frameFinishTaskQueue;
	static addSingleton<T extends Singleton>(singletonType: new () => T, isNotify?: boolean): T;
	static waitFrameFinish(): Promise<void>;
	static update(): void;
	static lateUpdate(): void;
	static frameFinishUpdate(): void;
	static dispose(): void;
}
export interface IEntity {
	instanceId: bigint;
	isDisposed: boolean;
	awake(): void;
	update(): void;
	lateUpdate(): void;
	destroy(): void;
}
export declare class EntityCenter extends Singleton {
	private _allEntities;
	add(entity: IEntity): void;
	remove(instanceId: bigint): void;
	get(instanceId: bigint): IEntity;
}
export interface IScene {
	sceneType: string;
}
export type T = Scene;
export declare abstract class AEventHandler<A> {
	protected abstract run(scene: T, args: A): any;
	handleAsync(scene: IScene, a: A): Promise<void>;
	handle(scene: IScene, a: A): void;
}
/**
 * 事件基类
 */
export declare abstract class AEvent extends RecycleObj {
}
/**
 * before singleton add
 *
 * NOTE: scene is null
 */
export declare class BeforeSingletonAdd extends AEvent {
	singletonType: Type<Singleton>;
}
/**
 * after singleton add
 *
 * NOTE: scene is null
 */
export declare class AfterSingletonAdd extends AEvent {
	singletonType: Type<Singleton>;
}
/**
 * before program init
 *
 * NOTE: scene is null
 */
export declare class BeforeProgramInit extends AEvent {
}
/**
 * after program init
 *
 * NOTE: scene is null
 */
export declare class AfterProgramInit extends AEvent {
}
/**
 * before program start
 *
 * NOTE: scene is null
 */
export declare class BeforeProgramStart extends AEvent {
}
/**
 * after program start,
 * you can listen this event and start your game logic
 *
 * NOTE: scene is null
 */
export declare class AfterProgramStart extends AEvent {
}
export declare const EventDecoratorType = "EventDecoratorType";
/**
 * 事件装饰器
 * @param event
 * @param sceneType
 * @returns
 */
export declare function EventDecorator(event: Type<AEvent>, sceneType: string): (target: Type) => void;
export declare class EventSystem extends Singleton {
	publishAsync<T extends AEvent>(scene: IScene, eventType: T): Promise<void>;
	/**
	 * 一定要确保事件处理函数不是异步方法
	 * 否则会导致事件处理顺序不一致和错误无法捕获
	 * @param scene
	 * @param eventType
	 * @returns
	 */
	publish<T extends AEvent>(scene: IScene, eventType: T): void;
}
export declare class TimeInfo extends Singleton {
	/**
	 * server time - client time
	 */
	serverMinusClientTime: number;
	awake(): void;
	clientNow(): number;
	serverNow(): number;
}
export declare class Options extends Singleton {
	/**
	 * 是否是服务端
	 */
	readonly isServer: boolean;
	/**
	 * log等级 越低输出信息越多
	 * 不能控制框架层的输出
	 */
	logLevel: number;
	/**
	 * 是否开发阶段
	 */
	develop: boolean;
}
export declare class JsHelper {
	static getMethodName(): string;
	static getRootDirName(path: string): string;
	static sleep(ms: number): Promise<void>;
	static isNullOrEmpty(str: string): boolean;
	static getStringHashCode(str: string): number;
	static modeString(str: string, mode: number): number;
	/**
	 * 格式化字符串
	 * @param str 包含有 0 个或者多个格式符的字符串
	 * @param args
	 * @returns 格式化后的新字符串
	 * @performance 性能是+号拼接10分之1, 也就是比较慢, 要注意性能
	 * ```
	 * formatStr("hello {0}", "world") => hello world
	 * formatStr("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
	 * formatStr("hello {{qaq}} {0}", "world") => hello {qaq} world
	 * ```
	 */
	static formatStr(str: string, ...args: any[]): string;
}
/**
 * 这个方法执行一个promise，如果promise出现异常，会打印异常信息
 * @param promise
 * @returns
 */
export declare function safeCall(promise: Promise<any>): Promise<any>;
export declare class DecoratorCollector {
	private static _inst;
	static get inst(): DecoratorCollector;
	private _decorators;
	add(decoratorType: string, ...args: any[]): void;
	get(decoratorType: string): Array<any>;
}
export type Action<T = any> = () => T;
/**
 * cancel token
 */
export declare class CancellationToken {
	private _actions;
	/**
	 * add one cancel action
	 * @param callback 添加取消动作
	 * @returns
	 */
	add(callback: Action): void;
	remove(callback: Action): void;
	/**
	 * 执行取消动作
	 * @returns
	 */
	cancel(): void;
	isCancel(): boolean;
	private invoke;
}
export declare class TimerMgr extends Singleton {
	private _timerMap;
	private _timers;
	/**
	 * 不断重复的定时器
	 * @param interval ms
	 * @param callback
	 * @param immediately 是否立即执行
	 * @returns
	 */
	newRepeatedTimer(interval: number, callback: Action, immediately?: boolean): number;
	/**
	 *
	 * @param timeout ms
	 * @param callback
	 * @returns
	 */
	newOnceTimer(timeout: number, callback: Action): number;
	newFrameTimer(callback: Action): number;
	remove(id: number): boolean;
	/**
	 * 浏览器上会有一个问题
	 * 就是cocos的update后台不执行,但是js脚本依然执行，导致大量的timer没回收
	 * 暂时不处理这个问题 应该没什么影响
	 */
	protected update(): void;
	/**
	 *
	 * @param time ms
	 * @param cancellationToken
	 * @returns
	 */
	waitAsync(time: number, cancellationToken?: CancellationToken): Promise<void>;
}
declare class Task<T = any> extends Promise<T> {
	private _resolve;
	/**
	 * 创建一个新的task
	 * @param type
	 * @returns
	 */
	static create<T = any>(type?: Type<T>): Task<T>;
	setResult(result?: T): void;
	/**
	 * 不允许直接new
	 * @param executor
	 */
	private constructor();
	private dispose;
}
export declare class CoroutineLockItem {
	key: string;
	task: Task;
	private _timeoutInfo;
	private _timerId;
	init(key: string): void;
	/**
	 * timeout tips
	 * @param timeout ms
	 * @param info
	 * @returns
	 */
	private setTimeout;
	private deleteTimeout;
	private timeout;
	dispose(): void;
}
export declare class CoroutineLock extends Singleton {
	private _lockMap;
	wait(lockType: string, key: string): Promise<CoroutineLockItem>;
	runNextLock(lock: CoroutineLockItem): void;
}
export interface IAssetOperationHandle {
}
export interface IBundleAssetProvider {
	asset: Asset;
	releaseHandle(handle: IAssetOperationHandle): any;
	internalLoad(): any;
}
declare class AssetOperationHandle {
	provider: IBundleAssetProvider;
	isDisposed: boolean;
	getAsset<T extends Asset>(assetType: Type<T>): T;
	dispose(): void;
	instantiateSync(): Node;
	instantiateAsync(): Promise<Node>;
}
declare class AssetSystem {
	/**
	 * 同时加载的最大数量
	 */
	private static _maxLoadingProvider;
	/**
	 * 每一帧最多添加几个到加载列表
	 */
	private static _frameMaxAddQueueProvider;
	private _waitLoads;
	private _loadingSet;
	private _frameAddCount;
	update(): void;
	addProvider(provider: IBundleAssetProvider): void;
	updateLoadingSet(): void;
	removeProvider(provider: IBundleAssetProvider): void;
}
declare class AssetInfo {
	bundleName: string;
	assetPath: string;
	assetType: Type<Asset>;
	uuid: string;
	init<T extends Asset>(assetType: Type<T>, location: string): void;
	private parseLocation;
}
export declare class BundleAsset {
	bundleName: string;
	bundle: AssetManager.Bundle;
	refCount: number;
	isAutoRelease: boolean;
	assetSystem: AssetSystem;
	private _providerMap;
	loadAssetAsync(assetInfo: AssetInfo): Promise<IAssetOperationHandle>;
	private createProvider;
	unloadUnusedAssets(): void;
}
export declare class MAssets extends Singleton {
	static assetSystem: AssetSystem;
	private static readonly _bundleMap;
	private static readonly _bundlePathMap;
	awake(): void;
	update(): void;
	static loadAssetAsync<T extends Asset>(assetType: new () => T, location: string): Promise<AssetOperationHandle>;
	static loadBundleAsync(bundleName: string): Promise<BundleAsset>;
	static releaseBundle(bundleAsset: BundleAsset): void;
	static unloadUnusedAssets(): void;
}

export {};
