// Generated by dts-bundle-generator v8.0.1

import { Asset, AssetManager, Component, EventTouch, Material, Node, SpriteAtlas, SpriteFrame, UIRenderer, UITransform } from 'cc';

/**
 * 构造函数
 */
export interface Type<T = any> extends Function {
	new (...args: any[]): T;
}
export interface ISceneInitArgs {
	id: bigint;
	instanceId?: bigint;
	sceneType: string;
	name: string;
	parent?: Entity;
}
export declare class Scene extends Entity {
	name: string;
	sceneType: string;
	set domain(value: Entity);
	get domain(): Entity;
	set parent(value: Entity);
	get parent(): Entity;
	init(args: ISceneInitArgs): void;
}
export declare abstract class Entity {
	get parent(): Entity;
	set parent(value: Entity);
	get domain(): Entity;
	set domain(value: Entity);
	instanceId: bigint;
	id: bigint;
	get isDisposed(): boolean;
	get children(): Map<bigint, Entity>;
	get components(): Map<Type<Entity>, Entity>;
	protected _domain: Entity;
	private _children;
	private _components;
	protected _parent: Entity;
	private _status;
	private get isFromPool();
	private set isFromPool(value);
	private get isComponent();
	private set isComponent(value);
	protected get isCreated(): boolean;
	protected set isCreated(value: boolean);
	protected get isNew(): boolean;
	protected set isNew(value: boolean);
	protected get isRegister(): boolean;
	protected set isRegister(value: boolean);
	private set componentParent(value);
	addCom(component: Entity): Entity;
	addCom<T extends Entity>(type: Type<T>): T;
	addCom<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	/**
	 * if not exist com will add new
	 * @param type
	 * @returns
	 */
	tryAddCom<T extends Entity>(type: Type<T>): T;
	private addComByEntity;
	private addComByType;
	addChild(entity: Entity): Entity;
	addChild<T extends Entity>(type: Type<T>): T;
	addChild<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	addChildWithId<T extends Entity>(type: Type<T>, id: bigint, isFromPool?: boolean): T;
	private addChildByEntity;
	private addChildByType;
	private create;
	private removeFromChildren;
	private removeFromComponents;
	private addToComponents;
	private addToChildren;
	getCom<K extends Entity>(type: new () => K): K;
	removeCom<T extends Entity>(type: Type<T>): T;
	getParent<T extends Entity>(type: Type<T>): T;
	getChild<T extends Entity>(type: Type<T>, id: bigint): T;
	removeChild(id: bigint): void;
	dispose(): void;
	domainScene(): Scene;
	getType(): Type;
	protected awake?(): void;
	protected update?(): void;
	protected lateUpdate?(): void;
	protected destroy?(): void;
}
export declare enum SceneType {
	NONE = "NONE",
	PROCESS = "PROCESS",
	CLIENT = "CLIENT",
	CURRENT = "CURRENT"
}
/**
 * 单例基类
 */
export declare abstract class Singleton {
	private static _inst;
	private _isDisposed;
	static get<T extends Singleton>(this: new () => T): T;
	get isDisposed(): boolean;
	dispose(): void;
	protected awake?(): void;
	/**
	 *
	 * @param dt ms
	 */
	protected update?(dt: number): void;
	/**
	 *
	 * @param dt ms
	 */
	protected lateUpdate?(dt: number): void;
	protected destroy?(): void;
	private _onPreDestroy;
}
/**
 * 保存根节点
 */
export declare class Root extends Singleton {
	get scene(): Scene;
	private _scene;
	awake(): void;
}
export interface IEntity {
	instanceId: bigint;
	isDisposed: boolean;
	awake(): void;
	update(): void;
	lateUpdate(): void;
	destroy(): void;
}
export declare class EntityCenter extends Singleton {
	private _allEntities;
	add(entity: IEntity): void;
	remove(instanceId: bigint): void;
	get(instanceId: bigint): IEntity;
}
export declare class ObjectPool extends Singleton {
	private _pool;
	fetch<T>(type: Type<T>): T;
	recycle(obj: object): void;
}
/**
 * 可回收对象
 */
export declare abstract class RecycleObj {
	private _isRecycle;
	/**
	 * 通过对象池创建
	 * @param this
	 * @param values
	 * @returns
	 */
	static create<T extends RecycleObj>(this: Type<T>, values?: Partial<T>): T;
	/**
	 * 如果是通过create方法创建的
	 * 那么dispose会回收到对象池
	 */
	dispose(): void;
}
export interface ILog {
	log(str: string): void;
	warn(str: string): void;
	error(str: string): void;
}
/**
 * Logger
 */
export declare class Logger extends Singleton {
	set iLog(value: ILog);
	static readonly LOG_LEVEL = 1;
	static readonly WARN_LEVEL = 2;
	private _logInst;
	private get _iLog();
	log(str: string, ...args: any[]): void;
	warn(str: string, ...args: any[]): void;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	error(str: string, ...args: any[]): void;
	private checkLogLevel;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreLog;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreWarn;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	private coreError;
}
/**
 * ```
 * log("hello {0}", "world") => hello world
 * log("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
 * log("hello {{qaq}} {0}", "world") => hello {qaq} world
 * ```
 * @param str
 * @param args
 */
export declare function log(str: string, ...args: any[]): void;
/**
 * ```
 * log("hello {0}", "world") => hello world
 * log("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
 * log("hello {{qaq}} {0}", "world") => hello {qaq} world
 * ```
 * @param str
 * @param args
 */
export declare function warn(str: string, ...args: any[]): void;
/**
 * ```
 * log("hello {0}", "world") => hello world
 * log("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
 * log("hello {{qaq}} {0}", "world") => hello {qaq} world
 * ```
 * @param str
 * @param args
 */
export declare function error(str: string, ...args: any[]): void;
export declare class IdGenerator extends Singleton {
	generateInstanceId(): bigint;
	generateId(): bigint;
}
export declare class IdStruct {
	private static _lastTime;
	private static _idCount;
	private static _inst;
	private static get inst();
	time: bigint;
	process: bigint;
	value: bigint;
	result: bigint;
	static generate(): bigint;
	static convertToId(time: number, process: number, value: number): bigint;
	/**
	 * convert id to 3 args
	 * not reference return value
	 * @param id bigint
	 * @returns
	 */
	static parseId(id: bigint): IdStruct;
	private static timeSinceEpoch;
	/**
	 * convert id to 3 args
	 * @param id bigint
	 * @returns
	 */
	initById(id: bigint): this;
	init(time: number, process: number, value: number): this;
	private updateResult;
}
export declare class InstanceIdStruct {
	private static _lastTime;
	private static _idCount;
	private static _inst;
	private static get inst();
	time: bigint;
	value: bigint;
	result: bigint;
	static generate(): bigint;
	static convertToId(time: number, value: number): bigint;
	/**
	 * convert id to 2 args
	 * not reference return value
	 * @param id bigint
	 * @returns
	 */
	static parseId(id: bigint): InstanceIdStruct;
	private static timeSinceEpoch;
	/**
	 * convert id to 3 args
	 * @param id bigint
	 * @returns
	 */
	initById(id: bigint): this;
	init(time: number, value: number): this;
	private updateResult;
}
export declare class Program {
	static init(rootNode: Node): void;
	/**
	 * 确保所有脚本已经加载之后调用start
	 */
	static start(): void;
}
export declare class Game {
	private static _singletonMap;
	private static _singletons;
	private static _destroys;
	private static _updates;
	private static _lateUpdates;
	private static _frameFinishTaskQueue;
	static addSingleton<T extends Singleton>(singletonType: new () => T, isNotify?: boolean): T;
	static waitFrameFinish(): Promise<void>;
	static update(dt: number): void;
	static lateUpdate(dt: number): void;
	static frameFinishUpdate(): void;
	static dispose(): void;
}
export interface IScene {
	sceneType: string;
}
export type T = Scene;
export declare const EventHandlerTag = "EventHandler";
export declare abstract class AEventHandler<A> {
	protected abstract run(scene: T, args: A): any;
	handleAsync(scene: IScene, a: A): Promise<void>;
	handle(scene: IScene, a: A): void;
}
/**
 * 事件基类
 */
export declare abstract class AEvent extends RecycleObj {
}
/**
 * before singleton add
 *
 * NOTE: scene is null
 */
export declare class BeforeSingletonAdd extends AEvent {
	singletonType: Type<Singleton>;
}
/**
 * after singleton add
 *
 * NOTE: scene is null
 */
export declare class AfterSingletonAdd extends AEvent {
	singletonType: Type<Singleton>;
}
/**
 * before program init
 *
 * NOTE: scene is null
 */
export declare class BeforeProgramInit extends AEvent {
}
/**
 * after program init
 *
 * NOTE: scene is null
 */
export declare class AfterProgramInit extends AEvent {
}
/**
 * before program start
 *
 * NOTE: scene is null
 */
export declare class BeforeProgramStart extends AEvent {
}
/**
 * after program start,
 * you can listen this event and start your game logic
 *
 * NOTE: scene is null
 */
export declare class AfterProgramStart extends AEvent {
}
/**
 * 创建ClientScene后
 */
export declare class AfterCreateClientScene extends AEvent {
}
/**
 * 创建CurrentScene后
 */
export declare class AfterCreateCurrentScene extends AEvent {
}
export declare const EventDecoratorType = "EventDecoratorType";
/**
 * 事件装饰器
 * @param event
 * @param sceneType
 * @returns
 */
export declare function EventDecorator(event: Type<AEvent>, sceneType: string): (target: Type) => void;
export declare class EventSystem extends Singleton {
	publishAsync<T extends AEvent>(scene: IScene, eventType: T): Promise<void>;
	/**
	 * 一定要确保事件处理函数不是异步方法
	 * 否则会导致事件处理顺序不一致和错误无法捕获
	 * @param scene
	 * @param eventType
	 * @returns
	 */
	publish<T extends AEvent>(scene: IScene, eventType: T): void;
}
export declare class TimeInfo extends Singleton {
	/**
	 * server time - client time
	 */
	serverMinusClientTime: number;
	/**
	 * 上一帧的增量时间，以毫秒为单位
	 */
	deltaTime: number;
	protected awake(): void;
	/**
	 * Returns the number of milliseconds elapsed since midnight, January 1, 1970 Universal Coordinated Time (UTC).
	 * @returns
	 */
	clientNow(): number;
	serverNow(): number;
	protected update(dt: number): void;
}
export declare class TimeHelper {
	static readonly oneDay: number;
	static readonly oneHour: number;
	static readonly oneMinute: number;
	static clientNow(): number;
	static clientNowSeconds(): number;
	static serverNow(): number;
}
export declare class Options extends Singleton {
	/**
	 * 是否是服务端
	 */
	readonly isServer: boolean;
	/**
	 * log等级 越低输出信息越多
	 * 不能控制框架层的输出
	 */
	logLevel: number;
	/**
	 * 是否开发阶段
	 */
	develop: boolean;
}
export declare class JsHelper {
	static getMethodName(): string;
	static getRootDirName(path: string): string;
	static sleep(ms: number): Promise<void>;
	static isNullOrEmpty(str: string): boolean;
	static getStringHashCode(str: string): number;
	static modeString(str: string, mode: number): number;
	static powBigInt(base: bigint, exp: bigint): bigint;
	/**
	 * 格式化字符串
	 * @param str 包含有 0 个或者多个格式符的字符串
	 * @param args
	 * @returns 格式化后的新字符串
	 * @performance 性能是+号拼接10分之1, 也就是比较慢, 要注意性能
	 * ```
	 * formatStr("hello {0}", "world") => hello world
	 * formatStr("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
	 * formatStr("hello {{qaq}} {0}", "world") => hello {qaq} world
	 * ```
	 */
	static formatStr(str: string, ...args: any[]): string;
}
/**
 * 这个方法执行一个promise，如果promise出现异常，会打印异常信息
 * @param promise
 * @returns
 */
export declare function safeCall(promise: Promise<any>): Promise<any>;
export declare class DecoratorCollector {
	private static _inst;
	static get inst(): DecoratorCollector;
	private _decorators;
	add(decoratorType: string, ...args: any[]): void;
	get(decoratorType: string): Array<any>;
}
export type Action<T = any> = () => T;
export type ActionAnyArgs<T = any> = (...args: any) => T;
export declare const CancellationTokenTag = "CancellationToken";
/**
 * cancel token
 */
export declare class CancellationToken {
	private _actions;
	/**
	 * add one cancel action
	 * @param callback 添加取消动作
	 * @returns
	 */
	add(callback: Action): void;
	remove(callback: Action): void;
	/**
	 * 执行取消动作
	 * @returns
	 */
	cancel(): void;
	isCancel(): boolean;
	private invoke;
}
export declare class TimerMgr extends Singleton {
	private _timerMap;
	private _timers;
	/**
	 * 不断重复的定时器
	 * @param interval ms
	 * @param callback
	 * @param immediately 是否立即执行
	 * @returns
	 */
	newRepeatedTimer(interval: number, callback: Action, immediately?: boolean): number;
	/**
	 *
	 * @param timeout ms
	 * @param callback
	 * @returns
	 */
	newOnceTimer(timeout: number, callback: Action): number;
	newFrameTimer(callback: Action): number;
	remove(id: number): boolean;
	/**
	 * 浏览器上会有一个问题
	 * 就是cocos的update后台不执行,但是js脚本依然执行，导致大量的timer没回收
	 * 暂时不处理这个问题 应该没什么影响
	 */
	protected update(): void;
	/**
	 *
	 * @param time ms
	 * @param cancellationToken
	 * @returns
	 */
	waitAsync(time: number, cancellationToken?: CancellationToken): Promise<void>;
}
export declare class Task<T = any> extends Promise<T> {
	private _resolve;
	/**
	 * 创建一个新的task
	 * @param type
	 * @returns
	 */
	static create<T = any>(type?: Type<T>): Task<T>;
	setResult(result?: T): void;
	/**
	 * 不允许直接new
	 * @param executor
	 */
	private constructor();
	private dispose;
}
export declare const CoroutineLockTag = "CoroutineLock";
export declare class CoroutineLockItem {
	key: string;
	task: Task;
	private _timeoutInfo;
	private _timerId;
	init(key: string): void;
	/**
	 * timeout tips
	 * @param timeout ms
	 * @param info
	 * @returns
	 */
	private setTimeout;
	private deleteTimeout;
	private timeout;
	dispose(): void;
}
export declare class CoroutineLock extends Singleton {
	private _lockMap;
	wait(lockType: string, key: string): Promise<CoroutineLockItem>;
	runNextLock(lock: CoroutineLockItem): void;
}
export declare class SceneFactory {
	static createClientScene(): Scene;
	static createCurrentScene(id: bigint, name: string): Scene;
}
/**
 * manage client scene
 */
export declare class SceneRefCom extends Entity {
	scene: Scene;
}
export interface Entity {
	currentScene(): Scene;
	clientScene(): Scene;
}
/**
 * 事件组件 可以发送事件给监听的对象
 * 不允许取消订阅
 */
export declare class EventCom extends Entity {
	private _eventMap;
	protected destroy(): void;
	/**
	 * evtCom.subscribe(123, this.onEvent, this)
	 * handler不需要绑定entity 也就是不需要bind
	 * @param eventType
	 * @param handler
	 * @param entity
	 */
	subscribe(eventType: string, handler: Function, entity: Entity): void;
	publish(eventType: string, ...args: any[]): void;
}
export interface IAssetOperationHandle {
}
export interface IBundleAssetProvider {
	asset: Asset;
	releaseHandle(handle: IAssetOperationHandle): any;
	internalLoad(): any;
}
export declare class AssetOperationHandle {
	provider: IBundleAssetProvider;
	isDisposed: boolean;
	getAsset<T extends Asset>(assetType: Type<T>): T;
	dispose(): void;
	instantiateSync(): Node;
	instantiateAsync(): Promise<Node>;
}
declare class AssetSystem {
	/**
	 * 同时加载的最大数量
	 */
	private static _maxLoadingProvider;
	/**
	 * 每一帧最多添加几个到加载列表
	 */
	private static _frameMaxAddQueueProvider;
	private _waitLoads;
	private _loadingSet;
	private _frameAddCount;
	update(): void;
	addProvider(provider: IBundleAssetProvider): void;
	updateLoadingSet(): void;
	removeProvider(provider: IBundleAssetProvider): void;
}
declare class AssetInfo {
	bundleName: string;
	assetPath: string;
	assetType: Type<Asset>;
	uuid: string;
	init<T extends Asset>(assetType: Type<T>, location: string): void;
	private parseLocation;
}
export declare class BundleAsset {
	bundleName: string;
	bundle: AssetManager.Bundle;
	refCount: number;
	isAutoRelease: boolean;
	assetSystem: AssetSystem;
	private _providerMap;
	loadAssetAsync(assetInfo: AssetInfo): Promise<IAssetOperationHandle>;
	private createProvider;
	unloadUnusedAssets(): void;
}
export declare class MoyeAssets extends Singleton {
	static assetSystem: AssetSystem;
	private static readonly _bundleMap;
	private static readonly _bundlePathMap;
	awake(): void;
	update(): void;
	static loadAssetAsync<T extends Asset>(assetType: new () => T, location: string): Promise<AssetOperationHandle>;
	static loadBundleAsync(bundleName: string): Promise<BundleAsset>;
	static releaseBundle(bundleAsset: BundleAsset): void;
	static unloadUnusedAssets(): void;
}
export declare enum WaitError {
	SUCCESS = 0,
	DESTROY = 1,
	CANCEL = 2,
	TIMEOUT = 3
}
export declare class AWait extends RecycleObj {
	error: WaitError;
}
export declare class ObjectWait extends Entity {
	private _tasks;
	protected destroy(): void;
	/**
	 * 一直等待 知道notify了 永不超时
	 * @param type
	 * @param cancellationToken
	 * @returns
	 */
	wait<T extends AWait>(type: Type<T>, cancellationToken?: CancellationToken): Promise<T>;
	/**
	 * 等待且有超时限制 超时将会取消等待
	 * @param type
	 * @param timeout ms
	 * @param cancellationToken
	 * @returns
	 */
	waitWithTimeout<T extends AWait>(type: Type<T>, timeout: number, cancellationToken?: CancellationToken): Promise<T>;
	/**
	 * 取消上一个等待
	 * @param type
	 */
	private cancelLastWait;
	/**
	 * 超时取消等待
	 * @param type
	 * @param time
	 * @param cancellationToken
	 * @returns
	 */
	private timeoutRun;
	private createWaitInstance;
	notify<T extends AWait>(obj: T): void;
}
/**
 * button async listener
 * wait for the callback to complete
 */
export declare class AsyncButtonListener {
	private _callback;
	private _isClick;
	constructor(func: ActionAnyArgs);
	invoke(...args: any[]): Promise<void>;
	static create(func: ActionAnyArgs): Action<void>;
}
export declare enum ViewLayer {
	/**
	 * 场景UI，如：点击建筑查看建筑信息---一般置于场景之上，界面UI之下
	 */
	SCENE = 1,
	/**
	 * 背景UI，如：主界面---一般情况下用户不能主动关闭，永远处于其它UI的最底层
	 */
	BACKGROUND = 2,
	/**
	 * 普通UI，一级、二级、三级等窗口---一般由用户点击打开的多级窗口
	 */
	NORMAL = 3,
	/**
	 * 信息UI---如：跑马灯、广播等---一般永远置于用户打开窗口顶层
	 */
	INFO = 4,
	/**
	 * 提示UI，如：错误弹窗，网络连接弹窗等
	 */
	TIPS = 5,
	/**
	 * 顶层UI，如：场景加载
	 */
	TOP = 6
}
export declare abstract class AMoyeView extends Entity {
	viewName: string;
	layer: ViewLayer;
	node: Node;
	private _viewMgr;
	/**
	 * on node load, this method will be called
	 */
	protected onLoad?(): void;
	/**
	 * on view visible, this method will be called
	 */
	protected onShow?(): void;
	/**
	 * on view invisible, this method will be called
	 */
	protected onHide?(): void;
	/**
	 * on node destroy, this method will be called
	 */
	protected destroy?(): void;
	/**
	 * the mothod can't get this.node, if you want get node on node load, use onLoad
	 */
	protected awake?(): void;
	private _realDispose;
	dispose(): void;
	bringToFront(): void;
}
export interface IMoyeViewConfig {
	/**
	 * after view hide, destroy view after expire(ms),
	 */
	expire: number;
	/**
	 * on view load, this method will be called, should return a node,
	 * @param viewName
	 */
	load(viewName: string): Promise<Node>;
	/**
	 * on view destroy, you can do some clean in this method,
	 */
	destroy(): void;
	/**
	 * before show do animation
	 * if animation done, you should call task.setResult()
	 * @param task
	 */
	doShowAnimation?(view: AMoyeView, task: Task): void;
	/**
	 * before hide do animation
	 * if animation done, you should call task.setResult()
	 * @param task
	 */
	doHideAnimation?(view: AMoyeView, task: Task): void;
}
export declare class MoyeViewMgr extends Entity {
	static inst: MoyeViewMgr;
	/**
	 * all views
	 */
	private _views;
	private _type2Names;
	private _showingViews;
	private _hideViews;
	private _viewCfgs;
	private _layers;
	private _globalViewCfgType;
	private _uiRoot;
	private _checkTimerId;
	private _checkInterval;
	protected awake(): void;
	protected destroy(): void;
	/**
	 * init view manager
	 * @param uiRoot
	 * @param globalViewCfg all field need to set
	 * @returns
	 */
	init(uiRoot: Node, globalViewCfg: Type<IMoyeViewConfig>): void | this;
	show<T extends AMoyeView>(type: Type<T>, bindEntity?: Entity): Promise<T>;
	show(name: string, bindEntity?: Entity): Promise<AMoyeView>;
	hide(name: string): Promise<void>;
	/**
	 * reload confog
	 */
	reload(): void;
	private check;
	private getLayerNode;
	private addToCleanCom;
	private enterViewShow;
	private enterViewHide;
	private enterViewDestroy;
}
export declare const ViewDecoratorType = "ViewDecorator";
export declare function ViewDecorator(name: string, layer: ViewLayer, viewCfg?: Type<IMoyeViewConfig>): (target: Type<AMoyeView>) => void;
export declare class SizeFollow extends Component {
	get target(): UITransform;
	set target(value: UITransform);
	private _target;
	set heightFollow(val: boolean);
	get heightFollow(): boolean;
	private _heightFollow;
	set widthFollow(val: boolean);
	get widthFollow(): boolean;
	private _widthFollow;
	private _heightOffset;
	private _widthOffset;
	private _changeSize;
	protected onLoad(): void;
	protected onDestroy(): void;
	private onTargetSizeChange;
	private updateSizeOffset;
}
declare enum WidgetDirection {
	LEFT = 1,
	RIGHT = 2,
	TOP = 3,
	BOTTOM = 4,
	LEFT_EXTEND = 5,
	RIGHT_EXTEND = 6,
	TOP_EXTEND = 7,
	BOTTOM_EXTEND = 8
}
/**
 * 关联组件
 * 不允许直系亲属互相关联
 * 同父支持size跟pos关联
 * 异父仅支持pos关联 size关联未做测试
 */
export declare class CTWidget extends Component {
	get target(): UITransform;
	set target(value: UITransform);
	private _target;
	set targetDir(val: WidgetDirection);
	get targetDir(): WidgetDirection;
	private _targetDir;
	set dir(val: WidgetDirection);
	get dir(): WidgetDirection;
	private _dir;
	visibleOffset: number;
	private _isVertical;
	private _distance;
	private _changePos;
	private _targetOldPos;
	private _targetOldSize;
	private _selfOldPos;
	private _selfOldSize;
	private _trans;
	protected onEnable(): void;
	protected onDisable(): void;
	protected onLoad(): void;
	protected onDestroy(): void;
	private registerEvt;
	private unregisterEvt;
	private updateData;
	private onTargetChange;
	private updateSize;
	private updatePos;
	private updateTargetPos;
	private updateDistance;
	private getPos;
}
export declare class RoundBoxSprite extends UIRenderer {
	protected _sizeMode: import("cc").__private._cocos_2d_components_sprite__SizeMode;
	get sizeMode(): import("cc").__private._cocos_2d_components_sprite__SizeMode;
	set sizeMode(value: import("cc").__private._cocos_2d_components_sprite__SizeMode);
	protected _atlas: SpriteAtlas | null;
	get spriteAtlas(): SpriteAtlas;
	set spriteAtlas(value: SpriteAtlas);
	_segments: number;
	get segments(): number;
	set segments(segments: number);
	_radius: number;
	get radius(): number;
	set radius(radius: number);
	protected _spriteFrame: SpriteFrame | null;
	get spriteFrame(): SpriteFrame;
	set spriteFrame(value: SpriteFrame);
	protected _leftTop: boolean;
	get leftTop(): boolean;
	set leftTop(value: boolean);
	protected _rightTop: boolean;
	get rightTop(): boolean;
	set rightTop(value: boolean);
	protected _leftBottom: boolean;
	get leftBottom(): boolean;
	set leftBottom(value: boolean);
	protected _rightBottom: boolean;
	get rightBottom(): boolean;
	set rightBottom(value: boolean);
	onLoad(): void;
	__preload(): void;
	onEnable(): void;
	onDestroy(): void;
	/**
	 * @en
	 * Quickly switch to other sprite frame in the sprite atlas.
	 * If there is no atlas, the switch fails.
	 *
	 * @zh
	 * 选取使用精灵图集中的其他精灵。
	 * @param name @en Name of the spriteFrame to switch. @zh 要切换的 spriteFrame 名字。
	 */
	changeSpriteFrameFromAtlas(name: string): void;
	/**
	 * @deprecated Since v3.7.0, this is an engine private interface that will be removed in the future.
	 */
	changeMaterialForDefine(): void;
	protected _updateBuiltinMaterial(): Material;
	protected _render(render: any): void;
	protected _canRender(): boolean;
	protected resetAssembler(): void;
	protected _flushAssembler(): void;
	private _applySpriteSize;
	private _resized;
	private _activateMaterial;
	private _updateUVs;
	private _applySpriteFrame;
}
declare enum DirectionType {
	FOUR = 0,
	EIGHT = 1,
	ALL = 2
}
/**
 * 速度类型
 */
export declare enum SpeedType {
	STOP = 0,
	NORMAL = 1,
	FAST = 2
}
declare enum JoystickType {
	FIXED = 0,
	FOLLOW = 1
}
export interface JoystickDataType {
	speedType: SpeedType;
	/**
	 * 移动向量
	 */
	moveVec: Vec3;
}
/**
 * 摇杆类
 */
export declare class YYJJoystick extends Component {
	dot: Node | null;
	ring: Node | null;
	joystickType: JoystickType;
	directionType: DirectionType;
	_stickPos: Vec3;
	_touchLocation: Vec2;
	radius: number;
	onLoad(): void;
	/**
	 * 启用时
	 */
	onEnable(): void;
	/**
	 * 禁用时
	 */
	onDisable(): void;
	/**
	 * 改变摇杆类型
	 * @param type
	 */
	_onSetJoystickType(type: JoystickType): void;
	/**
	 * 初始化触摸事件
	 */
	_initTouchEvent(): void;
	/**
	 * 触摸开始回调函数
	 * @param event
	 */
	_touchStartEvent(event: EventTouch): void;
	/**
	 * 触摸移动回调函数
	 * @param event
	 */
	_touchMoveEvent(event: EventTouch): boolean;
	/**
	 * 触摸结束回调函数
	 * @param event
	 */
	_touchEndEvent(event: EventTouch): void;
}
export interface IYYJJoystickEntity extends Entity {
	speedChange(type: SpeedType, speed: number): void;
	setPos(pos: Vec3): void;
	getPos(): Vec3;
	setAngle(angle: number): void;
}
export declare class YYJJoystickCom extends Entity {
	/**
	 * "移动方向"
	 */
	moveDir: Vec3;
	/**
	 * 速度级别
	 */
	private _speedType;
	/**
	 * 移动速度
	 */
	private _moveSpeed;
	/**
	 * 停止时速度
	 */
	stopSpeed: number;
	/**
	 * 正常速度
	 */
	normalSpeed: number;
	/**
	 * 最快速度
	 */
	fastSpeed: number;
	/**
	 * 是否设置角度
	 */
	isRotation: boolean;
	private _entity;
	init(entity: IYYJJoystickEntity): this;
	protected destroy(): void;
	onTouchStart(): void;
	onTouchMove(event: EventTouch, data: JoystickDataType): void;
	onTouchEnd(event: EventTouch, data: JoystickDataType): void;
	/**
	* set moveSpeed by SpeedType
	* @param speedType
	*/
	onSetMoveSpeed(speedType: SpeedType): void;
	/**
	 * 移动
	 */
	move(): void;
	update(): void;
}
export declare class YYJJoystickSpeedChangeEvent extends AEvent {
	speedType: SpeedType;
}
export declare class YYJJoystickMoveEvent extends AEvent {
	dir: Vec3;
}
export declare class YYJJoystickListener extends Entity {
	private _speedType;
	protected awake(): void;
	protected destroy(): void;
	onTouchStart(): void;
	onTouchMove(event: EventTouch, data: JoystickDataType): void;
	onTouchEnd(event: EventTouch, data: JoystickDataType): void;
}

export {};
